---
title: JVM-堆中对象的创建及布局
date: 2017-10-18 16:45:49
tags: [Java,JVM]
categories: JVM
---

**注意：**

- 本文描述的是HotSpot实现下的情况
- 对象指的是普通的实例对象，不包括类对象及数组对象

<!-- more -->

# 对象的创建

可以模拟一个实际场景：

```
Ob o = new Ob();
```

这行代码在JVM中实际的执行步骤如下：

**1.确保用于生成实例的模版已准备好**

检查Ob是否能在方法区的运行时常量池中定位到一个类的符号引用，并检查这个符号引用所代表的类是否已完成了加载，连接(验证，准备，解析)，初始化。若没有，则完成。

**2.JVM为实例分配内存**

某类的实例所需的内存大小在类加载完成后便已完全确定，因此对于同一个类的不同实例，JVM所分配的内存空间都是完全相同的。

有如下两种划分方式：

- 指针碰撞(Bump the Pointer)：若堆中已用内存及空闲内存的划分是规整的，即我们可以设置一个指针作为分界线，在指针的一边的内存空间全部为已用空间，另一边的空间则全部为空闲空间。那么只要将指针向空闲空间那边移动相应空间的距离即可完成内存分配。
- 空闲列表(Free List)：若堆中已用内存及空闲内存的划分不是规整的，那么JVM就需要维护一张空闲列表，每次需要分配新的内存空间时，就从空闲列表中找到一份足够大的空间，分配后再更新这个列表。

而堆是否规整主要依垃圾收集器是否有压缩整理的功能而定。因此使用Serial及ParNew等带有压缩整理的垃圾收集器时采用指针碰撞。使用CMS这种基于Mark-Sweep算法的垃圾收集器时则采用空闲列表。

分配内存空间时还应关注线程安全问题：例如采用指针碰撞时，线程1为对象a申请内存空间，指针还没来得及移动，线程2又为对象b申请了内存空间。解决策略主要有二：

- 采用CAS配上失败重试的方式保证内存分配的原子性。
- 为每个线程在堆中分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。只有当分配给某线程的堆空间不足需要扩展时才会进行同步控制。虚拟机 开启/关闭 TLAB可通过 -XX:+/-UseTLAB 参数设置。

**3.初始化内存空间**

除对象头外，JVM会将分配出去的内存空间都初始化为零值。该操作也是对象的实例成员变量未在代码中显式初始化也能直接使用的原因(当然，读到的结果为对应类型的零值)。相对的，方法中的局部变量就没有这个初始化的操作，因此必须显式声明，否则无法通过编译。

**4.初始化对象头**

对象头(Object Header)相当于该对象的描述信息，例如：

- 这个对象是哪个类的实例
- 如何才能找到类的元数据信息(即与方法区中存储的类的模版信息进行关联)
- 对象的哈希码
- 对象的GC分代年龄

等。

根据JVM当前运行状态的不同，例如是否启用偏向锁等，对象头会有不同的设置方式。

至此，从JVM的角度来看，对象分配已然结束了，再接下来就是对象内部操作自己得到的内存了。

**5.赋初值**

&lt;init&gt;方法会将对象按照程序员的意愿进行初始化，即赋上程序员为实例字段设置的值，其内部会调用对象对应的构造函数。

至此，一个对象的创建已经完成。

# 对象的内存布局

在HotSpot中，内存中存储的对象可分为3块：对象头(Header)，实例数据(Instance Data)和对齐填充(Padding)。

**对象头**

对象头又可分为两部分：Mark Word及类型指针。

所谓Mark Word即为对象的运行时描述信息，如哈希码(HashCode)，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等。在32位及64位(未开启指针压缩)的JVM上的长度分别为32及64位。实际上Mark Word中所存储的全部状态信息已无法用32位或64位完全表示，而Mark Word又只是一个与对象实际信息无关的描述信息，为了节省内存空间，Mark Word采用了一种非固定的数据结构：对象处于不同状态时需存储的状态信息不同，数据结构也不同。对象的状态列举如下：

![0.png](/images/blog_pic/JVM/堆中对象的创建及布局/0.png)

例如标志为01，即对象状态为未锁定时，对于32位的JVM而言，2位用于存储标志信息，25位用于存储对象的哈希码，4位用于存储对象的分代年龄，1位固定为0。

类型指针并非对象头中的必要元素。这牵涉到对象的访问定位。我们通过栈上的reference来访问堆上的对象，而如何定位，定位到哪里，JVM规范中并没有具体规定。目前主流的访问方式有两种：

使用句柄：

![1.jpg](/images/blog_pic/JVM/堆中对象的创建及布局/1.jpg)

使用直接指针(此时对象头中就要存储类型指针了)：

![2.jpg](/images/blog_pic/JVM/堆中对象的创建及布局/2.jpg)

使用句柄的好处为reference中存储的为稳定的句柄地址，在对象被移动时(垃圾收集时移动对象是很常见的行为)只需要修改句柄中对象的实际地址，而reference中存储的句柄地址则无需修改。

使用直接指针的好处为减少了一次指针定位。由于对象的访问非常频繁，因此积少成多这也节省了一笔非常可观的时间开销。

HotSpot使用直接指针的方式来定位对象，因此对象头中需要存储类型指针。

除Mark Word及类型指针外，若对象为数组，那么对象头中还必须有一块记录数组长度的区域。因为JVM可以通过普通对象的元数据确定其大小，却无法通过数组对象的元数据确定其大小。

**实例数据**

对象真正存储的有效信息，即各种类型的字段信息，包括从父类中继承而得的及在自身类中定义的。

字段的存储顺序由JVM的分配策略参数(FieldsAllocationStyle)所确定，依分配策略参数无法确定顺序的字段则由字段在代码中的定义顺序而定(父类中定义的变量会出现在子类之前)。

HotSpot默认的分配策略参数依类型所占用内存空间的大小降序排列： long/double ,int, short/char , byte/boolean ,oop(Ordinary Object Pointer，普通对象指针，即reference类型)。这样分配的好处在于宽度临近的类型总被分配在附近。

**对齐填充**

HotSpot的自动内存管理系统要求对象的起始地址必须是8字节的整数倍。因此当 对象头+实例数据 不是8字节的整数倍时，就以对齐填充的方式补全。该部分仅仅起到一个占位符的作用，不是必然会存在的(若 对象头+实例数据 恰好为8字节的整数倍该部分就不需要存在)。