---
title: JVM-运行时栈帧结构
date: 2017-12-05 15:44:49
tags: [Java,JVM]
categories: JVM
---

JVM是一种虚拟机，而虚拟机又是一个相对于物理机的概念。这两种机器都有代码执行能力，其区别在于物理机的执行引擎是直接建立在CPU，内存等硬件，指令集和操作系统层面上的。而虚拟机则是更上层的东西，其必须位于某个物理机中，受该物理机各方面因素的掣肘，但是它的执行引擎却是自行实现的，具体来说，就是指指令集及执行引擎的结构体系等各种架构都是自行设计的。因此，它虽然位于物理机中，却仿佛是一台独立的机器：能够执行那些不被该物理机的硬件所直接支持的指令。

<!-- more -->

显然，无论是物理机还是虚拟机，执行引擎都是最核心的组件之一。JVM规范中制定了JVM字节码执行引擎的概念模型(多说一句感想，关于Java，SUN建立了几乎全部的规范和标准，正所谓一流的公司卖标准，二流的公司卖产品，三流的公司帮二流的公司卖产品)，该概念模型成为了所有遵守JVM规范的JVM实现的执行引擎的统一外观(Facade)。不同的JVM实现可能会采取不同的具体执行方式：

- 通过解释器解释执行，即通常意义上的解释执行
- 通过即时编译器(JIT)直接产生本地机器码，也就是通常意义上的编译执行

虽然各实现采取的策略往往不同，即可能只采取解释执行(例如SUN早期的JVM实现Sun Classic VM)，可能只采取编译执行(例如BEA JRockit)。或者混合使用解释执行及编译执行(例如最常用的Hotspot VM)。但是无论如何，它们都是基于同一套规范的不同实现，因此从外观上来看，所有的JVM执行引擎的行为都是一致的：输入JVM的是字节码流，处理过程是字节码解析的等效过程，输出的是执行结果。

在JVM的运行时内存中，类的模版信息位于方法区中，实例对象位于Java堆中。这些内存区域都可以看作是存储数据的仓库，映射到计算机组成原理中，可以看作是内存。而虚拟机栈和本地方法栈(可看作缓存和寄存器)则是直接与JVM字节码执行引擎(可看作CPU)交互的内存区域。

CPU将所需的数据从内存中取到自身的缓存中，在执行每条指令时，都会将该指令所需的参数加载到自身的寄存器中，计算完成后将结果放回寄存器。再通过寄存器放回缓存。随后在合适的时机写回内存。因此，从更本质的角度上说，与CPU直接交互的只有寄存器。

类似的，JVM执行引擎在执行一组字节码指令时也会先将所需数据取到线程的虚拟机栈或本地方法栈中并建立栈帧(以使用实例对象为例，实际上并不是真的把该实例从Java堆中复制到了栈帧中，拿过来的仅仅是引用)，或者更具体的说，这些数据被存到了栈帧的局部变量表中，而后在执行每条字节码指令时，都会将这条指令所需的数据加载入栈帧的操作数栈中(强调一下，JVM不是基于寄存器的，是基于操作数栈的)，计算完成后再将结果放回操作数栈，而后再在合适的时机放回局部变量表(因为拿过来的就是引用，所以除了基本数据类型这种数值以外，不需要再同步了)。因此，从更本质的角度上说，与JVM字节码执行引擎直接交互的只有栈帧中的操作数栈。

本文所要描述的就是这个供JVM字节码执行引擎使用的，运行时栈帧结构的概念模型。

虚拟机栈及本地方法栈就只是一个栈式结构，本身并没有什么可说的。其所有逻辑基本都在其元素：栈帧中。因此所谓的介绍运行时栈帧结构，实际上就是介绍栈帧。

栈帧(Stack Frame)是用于支持JVM进行方法调用和方法执行的数据结构。Java中每一个方法在运行期从调用开始到执行完成的过程，实际上就是一个栈帧从入栈到出栈的过程。

![0.jpg](/images/blog_pic/JVM/运行时栈帧结构/0.jpg)

在上图中，最大的圆角矩形是当前线程私有的虚拟机栈。若一个方法在其内部又调用了另一个方法(调用自己则被称为递归)，则每调用一个新的方法都会压入一个新的代表该方法的栈帧。因此一个线程中的方法调用链可能会很长，也就是该线程的虚拟机栈中的元素可能会很多。不过对于JVM执行引擎而言，对于任意特定时刻，只有位于栈顶的栈帧才是有意义的，该栈帧被称为当前栈帧(Current Stack Frame)，相应的，该栈帧所关联的那个方法被称为当前方法(Current Method)。操作数栈的信息永远来自于当前栈帧，或者更本质的说，JVM执行引擎操作的所有数据都来自于当前栈帧。

每个栈帧主要包含如下信息：

- 局部变量表
- 操作数栈
- 动态连接
- 方法返回地址
- 一些额外的附加信息

栈帧中需要多大的局部变量表，多深的操作数栈在编译期已完全确定，并存入：

class文件-方法表集合-方法表-属性表集合-Code属性-其中有代表操作数栈最大深度的max_stack及代表局部变量表所需存储空间(单位为Slot，并可认为一个Slot 32位)的max_locals。详见[JVM-类文件结构](/2017/11/07/JVM-类文件结构/)。

局部变量表及操作数栈这两个变长的数据结构占据了栈帧绝大部分的空间(其他组成结构的长度固定)，因为它们的大小在编译期已确定，因此栈帧的大小在运行期是固定的。

下文将逐个介绍栈帧的各组成部分。

# 局部变量表

局部变量表(Local Variable Table)是一组变量值的存储空间，用于存储方法的传入参数和在方法内部定义的局部变量。局部变量表的大小在编译期即完全确定，并存入：

class文件-方法表集合-方法表-属性表集合-Code属性-代表局部变量表所需存储空间的max_locals。

max_locals是一个整型数值，其基本单位被称为变量槽(Variable Slot，常简称为Slot)。JVM规范并没有明确规定一个Slot占多少位，然而纯从字面上考虑，变量槽，也就是放变量的槽，一个槽里总要放得下一个变量才是。JVM规范虽然没有明说一个Slot多大，却正如刚才我们顾名思义所推测的，说了这么一句话：一个Slot必须能容纳一个boolean,char,byte,short,int,float,reference或returnAddress类型。这8种数据类型最大的占用32位，因此一个Slot最小也得有32位。这个与直接规定一个Slot是32位是有区别的。相当于留下了向上扩展的余地。不过我们一般说到Slot时都会把它看作32位。

关于reference类型的长度，可以多说几句。事实上，JVM规范既没有给出reference类型的数据结构，也没有明确规定reference类型的长度，32位系统下reference类型的长度为32位，64位系统若开启了对象指针压缩的优化则长度为32位，否则为64位。不那么较真的情况下，通常我们都认为reference类型是32位的。虽然JVM规范对reference类型的要求很是模糊，但一般来说，JVM实现至少应该可以使用reference类型做到如下两点：一是从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引(找到实例信息)。二是从此引用中直接或间接地查找到对象所属的类在方法区中存储的类型信息(找到模版信息)。二者结合才是一个完整的对象信息。否则就无法实现Java语言规范中规定的语法约束(并非所有语言都能实现这两个要求，例如C++就仅实现了第一点，未实现第二点)。

returnAddress类型配合jsr,jsr_w,ret等跳转相关的指令使用，用于在跳转后指向需返回的字节码偏移量。历史上曾使用该机制处理异常，自JDK1.7起returnAddress连同这些字节码指令均被废弃，异常机制使用class文件-方法表集合-方法表-属性表集合-Code属性-异常表集合实现。

上文中讨论的数据类型都是小于等于32位的(姑且认为引用类型就是32位的)，而Java语言规范中明确规定大于32位的数据类型只有两种，且均为64位，即long,double。对于这两种类型，JVM会采取高位对齐的方式(也就是前32位是高位，后32位是低位)为其分配两个连续的Slot。即取用时是这样的：

```
(前32位 << 32) | 后32位
```

这种把long和double分割存储的思路和Java内存模型中关于long和double的非原子协定(将1次对64位数据的读写操作拆解为两次对32位数据的读写操作。因此这次对64位数据的读写操作就不是原子的了)很类似。不过局部变量表位于栈帧中，栈帧位于虚拟机栈或本地方法栈中，而栈又是线程私有的，因此不会涉及到线程安全问题。

JVM通过索引来定位局部变量表中的变量。因此局部变量表看起来就像是一个数组。若某局部变量表占用空间为solt_count个solt，则其索引范围为[0,solt_count-1]。对于那些能被1个Slot所容纳的数据类型而言，一个Slot中放置一个变量。对于long及double这两个64位的数据类型而言，两个Slot才能容纳一个变量，该变量的索引为其所占据的第一个Slot的索引。在字节码指令调用这件事上，每个变量都是不可再分割的整体，因此调用这些变量的第二个Slot的索引是不合法的，其应该在类加载的连接-验证-字节码验证阶段被检查出来并抛出相应的异常。

关于局部变量表中变量的顺序，默认先按照传入顺序存入方法的传入参数，而后再结合局部变量在方法体内部的声明顺序和作用域分配剩余Slot。特别的，若方法为实例方法，那么传入参数列表中将默认隐含该实例方法所属实例的引用(也就是我们在代码中常用的this)，并且该引用将固定占据局部变量表的0号索引。

因为局部变量都是有作用域的，因此若当前程序计数器中指明的指令偏移量已超出了某局部变量的作用范围，该局部变量实际上就已经没用了。因此局部变量表中的Slot是可以复用的，从而节省了栈帧的使用空间。不过，这种复用的设计在某些情况下可能会产生负面影响，例如影响JVM的GC系统。我们来看下面的代码：

```
public class Test { 

    /**
     * 启动参数：-verbose:gc
     */
    public static void main(String[] args) {
        byte[] byteArray = new byte[100 * 1024 * 1024];
        System.gc();
    }
```

一个byte占据1字节(1B)，除去数组本身所需的少量内存空间，byteArray共使用100MB的空间，我们来运行以下这段代码：

```
[GC 103731K->102952K(227328K), 0.0140411 secs]
[Full GC 102952K->102868K(227328K), 0.0121913 secs]
```

byteArray所使用的这100MB空间并没有被GC回收掉，这个很好理解，毕竟System.gc()执行时并未超出byteArray的作用域，那么我们再做如下修改：

```
public class Test { 

    /**
     * 启动参数：-verbose:gc
     */
    public static void main(String[] args) {
        {
            byte[] byteArray = new byte[100 * 1024 * 1024];
        }
        System.gc();
    }
}
```

输出：

```
[GC 103731K->102968K(227328K), 0.0020960 secs]
[Full GC 102968K->102868K(227328K), 0.0121942 secs]
```

byteArray依然没有被GC回收。这就让人有些疑惑了，因为此次System.gc()执行时已经超出byteArray的作用域了，byteArray已经没用了，GC为什么不回收它呢？在回答这个问题之前，我们不妨再修改一下这段代码：

```
public class Test { 

    /**
     * 启动参数：-verbose:gc
     */
    public static void main(String[] args) {
        {
            byte[] byteArray = new byte[100 * 1024 * 1024];
        }
        byte b = 1;
        System.gc();
    }
}
```

这个局部变量b加的看起来有些莫名其妙，然而此时我们再次运行这段代码：

```
[GC 103065K->103016K(227328K), 0.0013827 secs]
[Full GC 103016K->468K(227328K), 0.0145637 secs]
```

这次byteArray终于被GC回收了。

在以上3个小例子中，byteArray能否被回收的核心依据为：局部变量表的Slot中是否还存着byteArray数组对象的引用。只要还存着，这个引用就将作为GC Root被GC所参考，从而让byteArray在可达性分析中逃过被打上GC标记的命运。第一次修改后，虽然System.gc()执行时已经超出byteArray的作用域了，但是在其执行前没有任何对局部变量表的读写操作，byteArray原本所占用的Slot还没有被其他变量所复用，因此自然无法回收。至此第二次修改的目的就很明确了，新定义的变量b重用了byteArray所占据的空间，从而byteArray得以被GC所回收。

绝大多数时候，这个例子所体现的问题并没有什么大不了的，因为并不是内存泄漏了，只是回收的没那么及时而已。不过某些情况下，若局部变量占据的内存很大，后文又会进行耗时很长的操作，导致这部分内存迟迟得不到回收，可能会出现不可接受的后果。

因此为了保险起见，显然手动处理一下才更为合理。不过第二次修改中那种莫名其妙的加一个不使用的局部变量的做法实在是有点2，通常我们会采取更易于理解，更优雅的做法：

```
public class Test { 

    /**
     * 启动参数：-verbose:gc
     */
    public static void main(String[] args) {
        byte[] byteArray = null;
        {
            byteArray = new byte[100 * 1024 * 1024];
        }
        byteArray = null;
        System.gc();
    }
}
```

这样的话，即便System.gc()执行时byteArray尚未被覆盖，但由于我们已经明确将其置为null，GC自然敢大胆的回收byteArray了。输出：

```
[GC 103065K->102968K(227328K), 0.0015879 secs]
[Full GC 102968K->468K(227328K), 0.0158991 secs]
```

因此，"不使用的对象应手动赋值为null"，是一个很有用的小技巧。不过也有人认为无需将其上升到"编程规范"的高度。原因主要有以下两点：

首先，从编写代码时的逻辑思路来看，通过合理的作用域来隐式的控制局部变量的GC才是最优雅的。赋null值其实是为了照顾JVM的缺陷而强行添加的补救措施。会破坏代码的完整性，使得开发过程不那么流畅。开发出的代码看起来也总有些别扭，不那么"美"。

其次，以上的小例子都是基于字节码执行引擎的概念模型，换句话说，如果有一个JVM的实现，老老实实的严格按照JVM规范来做，可灵活实现的地方也采取尽量简单笨拙的方式，对于这种采用纯解释执行又没有太多优化的JVM实现而言(例如JDK1.0时代的默认JVM实现Sun Classic VM)，上述3个小例子中的问题是会存在的。然而当今JVM早已采用了编译与解释混合执行的方式。以Hotspot而言，若某方法被编译为本地代码(Java编译的默认单位是方法)，在开启JIT编译优化后，赋null值这种操作就会被编译优化去掉，也就是说此时写了也白写。同时字节码被编译为本地代码后，对GC Roots的枚举方式也与解释执行(或者也可以说我们通常在分析GC时使用的那个模型)时有巨大差别，仍分析上文的小例子，若其被JIT编译为了本地代码，即便没有添加赋null值的代码，也能正确及时回收局部变量(***只是理论，我通过增加回边数成功触发编译了，然而并未成功回收byteArray，可能是哪里编写得尚有问题***)。

---

对于类变量而言，存在两次赋值(详见[JVM-类加载机制](/2017/11/23/JVM-类加载机制/))。第一次是类加载的连接-准备阶段，JVM会为其赋上对应数据类型的零值。第二次是类加载的初始化阶段，会赋上开发人员在代码里定义的具体值。因此，即便初始化阶段没有赋值也不会产生异常，因为类变量已被填入零值。换句话说，我们可以在代码中定义类似这样的类变量：

```
private static int V_1;
```

此时虽然看似V_1并没有被赋值，但实际上其会在类加载的连接-准备阶段赋上int型的零值0。

类似的，对于实例变量而言，虽然赋值时机不同，然而依然会经历类似的两次赋值。因此我们可以下述代码：

```
private int v2;
```

v2也会被默认填入int型的零值0。

然而对于局部变量而言，其并没有JVM为其默认赋零值的阶段。因此单单只是声明一个局部变量是无法使用的。例如以下代码是无法通过编译的，会提示The local variable v may not have been initialized。

```
public class Test { 

    public static void main(String[] args) {
        int v;
        System.out.println(v);
    }
}
```

# 操作数栈

JVM的解释执行引擎被称为基于栈的执行引擎。这里的栈指的就是操作数栈。

操作数栈(Operand Stack)也称作操作栈，它既然被称为栈，自然具备栈结构的基本特性：后人先出(LIFO,Last In First Out)。同局部变量表一样，操作数栈的最大深度也会在编译期确定，并写入：

class文件-方法表集合-方法表-属性表集合-Code属性-代表操作数栈最大深度的max_stack。

max_stack的基本单位为32位。即max_stack=3表示该操作数栈能容纳3个基本元素，每个基本元素的大小为32位。对于long和double这两个64位的数据类型而言，它们将占据两个基本栈元素的空间。这与局部变量表的Slot体系是对应的。

max_stack的计算法则为，在保证任何时刻操作数栈压入基本栈元素的个数小于等于max_stack的前提下，让max_stack尽量的小。换句话说，max_stack就是方法整个运行周期中可能装入的最大的栈元素的个数。

方法刚开始执行时操作数栈是空的，随着方法体中代码的执行(其实就是依逻辑调用class文件-方法表集合-方法表-属性表集合-Code属性-字节码指令集合中的字节码指令组合)，字节码指令会将执行所需的数据压入操作数栈，计算完成后再将结果压入操作数栈。例如在执行int型加法指令iadd时，会将栈顶的两个int型整数弹出，相加后再将得到的int型结果压回操作数栈。由这个小例子我们也可以看出，字节码指令在执行时操作数栈栈顶的元素必须与该字节码指令严格配合。例如在iadd时，若栈顶的两个元素是一个float一个int，iadd会执行失败。Java设计者在编译期保证了这一点，同时也会在运行期的类加载的连接-验证-字节码验证阶段确认这一点。

在JVM规范所给出的概念模型中，虚拟机栈或本地方法栈中的栈帧间是完全独立的。然而大多数JVM实现都会做一些优化处理，令相邻的两个栈帧间出现一部分重叠。如下图所示。

![1.png](/images/blog_pic/JVM/运行时栈帧结构/1.png)

方法链的调用往往遵循以下规则：执行到某条方法调用命令，该命令读取操作数栈中的参数(例如新方法的全路径名，描述符，所需参数等)调用新方法并压入代表这个新方法的栈帧。如果栈帧间是完全独立的，那么这个新的栈帧所需的传入参数必须要由调用它的方法复制一份，而这种复制行为其实是可以很容易避免的。解决策略就是上图的做法。每个栈帧的最下部是局部变量表，最上部是操作数栈，这样对于紧邻的两个栈帧而言，就可以让下面的栈帧中的操作数栈与上面的栈帧的局部变量表共享一部分信息，避免了入参的复制。节省空间，提高效率。

# 动态连接

Class文件的常量池集合在记录方法时使用的是符号引用。而想要使用是必须进行连接的(也就是将符号引用替换为直接引用)。其连接原则就是只要能确定具体调用的方法了，就尽早进行连接。因此，编译期就能确定调用版本(注意，编译期仅仅是能确定，而并未真的替换。所有连接的替换操作都是发生在运行期的)的方法会在类加载的连接-解析阶段或者第一次使用时转化为直接引用。

能被子类继承的方法是无法在编译期确定版本的。因为编译期只能得到该引用的静态类型，若方法能被继承，说明当具体运行到这一句字节码指令时，其实际类型可能与静态类型不同(实际类型可能是该静态类型，也可能是该静态类型的子类)。而编译期显然不能预测到该实际类型到底是什么。

不过反过来说，如果一个方法不允许被子类继承，那么它必然可以在编译期就确定调用版本。这些方法包括：静态方法，私有方法，构造方法，被final修饰的方法等。这些方法的连接过程被称为解析。其连接手段是静态多分派。

而对于剩下那些能被子类继承的方法而言，除了依然要进行静态多分派之外，当程序执行到该字节码指令时，还要进行动态单分派。这些方法至此才能真正的完成连接操作。它们在执行阶段进行的连接操作被称为动态连接(Dynamic Linking)。

每个栈帧都会包含一个指向运行时常量池中该栈帧所属方法实际版本的引用，其值是动态连接之后的结果(当然，无法被继承的方法在方法调用版本判断时是没有动态连接这一步的，不过统一都这样称呼)，因此也称为栈帧中的动态连接信息(Dynamic Linking)。

# 方法返回地址

首先需要明确的是，这里所说的栈帧中的方法返回地址(Return Address)与上文局部变量表中说到的那个被废弃的数据类型returnAddress从名字上来看很相似，但实际上二者完全没有关系。

当一个方法开始执行后(即产生了栈帧并压入操作数栈)，只有两种方式可以退出这个方法(即该方法对应的栈帧从操作数栈中弹出)。

第一种退出方式被称为正常完成出口(Normal Method Invocation Completion)。一如其名，也就是方法顺顺利利的执行完成。此种方式的触发条件为字节码执行引擎遇到任意一个表示方法返回的字节码指令。这时可能会有返回值传递给上层的方法调用者(即调用该方法的方法)。是否有返回值及返回值的类型将由遇到的那条方法返回指令决定。

另一种退出方式被称为异常完成出口(Abrupt Method Invocation Completion)。自然指得就是方法在执行过程中遇到异常(包括JVM内部产生的异常及代码使用athrow字节码指令手动抛出的异常)，并且该异常本方法无法处理(即本方法的异常表中没有搜索到匹配的异常处理器，该异常表存储于class文件-方法表集合-方法表-属性表集合-Code属性-异常表集合)。就会导致方法退出。使用这种方式退出的方法是不会给它上层的方法调用者传递任何返回值的。

无论采用哪种退出方式，在方法结束后，都需要返回到它的上层方法调用者调用它的位置，这样程序才能继续执行。方法结束实际上就意味着当前栈帧的出栈。此时需执行的操作可能有：

- 恢复上层方法调用者的局部变量表和操作数栈
- 把返回值(如果有的话)压入上层方法调用者的操作数栈中
- 调整所属线程的PC计数器的值以指向上层方法调用者调用本方法那条指令的下一条指令
- 等等

因此方法返回时可能需要在栈帧中保存一些信息，用于支持上述操作。这部分信息就被称为操作数栈的方法返回地址。一般来说，方法正常退出时，调整后的所属线程的PC计数器的值会存在栈帧的方法返回地址中。而当方法异常退出时，该值将由异常表来决定，因此通常不会存在栈帧中。

# 附加信息

JVM规范允许具体的JVM实现增加一些自定义的信息到栈帧中。例如与调试相关的信息。附加信息完全取决于具体的JVM实现，算是JVM规范在实现灵活性上留的尺度比较大的一个口子。

在实际开发中，一般会将动态连接，方法返回地址与附加信息这3个比较零碎的信息归为一类，统称为栈帧信息。