---
title: JVM-字节码解释执行引擎
date: 2017-12-11 14:54:49
tags: [Java,JVM]
categories: JVM
---

JVM对于字节码指令的执行方法有两种：

- 解释执行：通过解释器执行
- 编译执行：通过即时编译器(JIT)产生本地代码执行

本文重点探讨解释执行的具体过程。

<!-- more -->

# 解释执行与编译执行

在真正开始讲解解释执行的具体过程之前，我想先提纲挈领的描述下解释执行与编译执行的区别。

Java经常会被人(尤其是主语言是其他开发语言的程序员)定位为解释执行的语言。其原因就在于1996年JDK1.0诞生时，其所使用的默认JVM为Sun Classic VM，这是一个纯解释执行的JVM，因此此时这样定位尚属准确。而到了1998年JDK1.2时，虽然默认JVM依然是Sun Classic VM，然而此时Sun Classic VM已不是唯一的JVM了，HotSpot VM这个解释与编译混合执行的JVM已被作为可选JVM加入JDK。而到了2000年的JDK1.3，HotSpot VM成为了默认JVM，Sun Classic VM降为可选JVM(JDK1.2到JDK1.3默认JVM的变化正所谓扶上马送一程)。自此以后用解释执行来描述Java就不再准确了，因为Class文件中的内容到底会被解释执行还是编译执行，就成了只有JVM自己才能准确判断的事情了。因此准确来说，Java是一门解释与编译混合执行的语言。

不过说真的，空洞的从理论上争论一个语言到底是解释执行还是编译执行其实意义并没有那么大。关键还是要结合实现，具体问题具体分析。高级编程语言也发展了这么多年了，其实际套路已无法完全遵循最初制定的框架(也就是计划赶不上变化)，C与C++现在也已经有了通过解释器执行的版本(如CINT)。而Java也不总是编译期与运行期断为两截了，也出现了直接将.java编译为本地机器代码的编译器(如GNU Compiler for the Java，即GCJ)。因此我们平常所说的"C/C++是编译执行的语言"，"Java是解释与编译混合执行的语言"等等所指的都是主流情况，而无法涵盖全部(因为实在也没必要较那个真)。

其实无论是基于物理机，JVM，亦或是其他的高级语言虚拟机(High Level Language Virtual Machine,HLLVM)，现代高级编程语言的执行流程都大同小异。在逻辑上基本不出下图的藩篱：

![0.png](/images/blog_pic/JVM/字节码解释执行引擎/0.png)

显然，最下面那行对应编译执行，中间那行对应解释执行。而中间那行中的"指令流"一步指的自然是javac编译器生成.class文件的过程了。

上图中的思路即为现代经典编译原理的思路。在执行前先对程序源码进行词法分析和语法分析处理，把源码转化为抽象语法树(Abstract Syntax Tree,AST)。具体到每一门语言，这一步大体上会有3种实现思路：

- 词法分析，语法分析，乃至后续的优化器及目标代码生成器等一切编译相关的组件均独立于执行器实现，形成一个完成的编译器。例如C/C++
- 将一部分组件(例如生成抽象语法树之前的步骤)实现为一个独立的编译器，而后续的步骤则与执行器混合在一起。例如Java
- 将所有的编译组件及执行组件均封装在一个黑盒中，例如大多数的JavaScript(JavaScript真不愧是以简单暴躁著称)

或者我们可以更具体一些，对于JDK而言，javac编译器完成了上图中程序源码到第二行中指令流之间的过程。因为这一部分动作是在JVM之外进行的，而解释器在JVM内部，所以我们也说Java的编译器是半独立实现的(JVM之外javac实现的那部分是独立的，而JVM内部的那部分则不是)。

# 基于栈的指令集与基于寄存器的指令集

JVM基本上是一种基于栈的指令集架构(Instruction Set Architecture,ISA)，指令依赖方法区-局部变量表-操作数栈进行工作。之所以说基本上，是因为纯粹的基于栈的指令集架构中的指令应该全部都是零地址指令，或者说是不带参数的指令。而JVM的指令集中有小部分指令是需要参数的。之所以做这个变通，是为了提高代码的可校验性。

与基于栈的指令集架构相对的另一套同样很常用的指令集架构是基于寄存器的指令集架构。最典型的就是x86的二地址指令集架构，或者更通俗的说，就是现在主流的PC微型机中直接支持的指令集架构，其中的指令依赖寄存器进行工作。那么，二者之间有何不同呢？

举个小例子，如果要计算1+1的结果，那么对于JVM中的基于栈的指令集而言是这样的：

```
iconst_1    // 将1压入操作数栈
iconst_1    // 将1压入操作数栈
iadd    // 弹出操作数栈栈顶的两个int型元素求和后再将int型结果压回操作数栈
istore_0    // 将操作数栈栈顶的int型元素弹出并存入局部变量表索引为0的Slot中
```

如果是针对基于寄存器的指令集架构的pc机而言，那么1+1是这样的：

```
mov eax, 1    // 将eax寄存器的值设为1
add eax, 1    // 将eax寄存器中的值加1并存回eax寄存器
```

那么这两套指令集哪一个更好一些呢？

其实这两套指令集能齐头并进的共同发展这么多年，本身便已给出答案了：自然是各有其优劣之处：某些场景下基于寄存器的指令集更好，另一些场景下则是基于栈的指令集更优秀一些。

基于栈的指令集较之基于寄存器的指令集最大的优势就在于栈更为抽象，从而易于移植。基于寄存器的指令集中所使用的寄存器往往由物理机在硬件上直接提供(之所以说往往，是因为也有基于虚拟机寄存器的例子。例如Google Android平台的Dalvik VM。不过，即便是基于虚拟机寄存器，也希望把虚拟机寄存器尽量映射到物理寄存器上以获得更高的性能)，这就不可避免的会受到硬件的约束。例如，32位80x86体系(主流PC机)的CPU提供了8个32位的寄存器，而ARM(主流手机)的CPU则提供了16个32位的通用寄存器。若使用基于寄存器架构的指令集，用户在编写指令时必须针对不同的物理寄存器设计不同的代码。而使用基于栈的指令集则屏蔽了这些底层的细节，用户使用的是抽象过的栈，至于具体的底层实现则交由虚拟机完成。

总结来说，基于栈的指令集会让程序员更为舒服，那么此消彼长，实际工作的虚拟机就不那么舒服了。上文中"具体的底层实现则交由虚拟机完成"意味着此时虚拟机需要做更多的操作，从而降低执行速度。因此，几乎所有主流的物理机的指令集都是基于寄存器的(因为也没什么可迁移的)。

通过上文1+1的小例子也可以看出：实现同一个功能，栈架构所用的指令往往要比寄存器架构所用的指令多(正如高级语言的源码通常会比汇编长那样)，因为对于实际功能而言，出栈入栈其实是多余的操作(更本质的来说，栈本身其实就是个多余的东西，因为虚拟机总归是要跑在物理机上的，而物理机又大多是基于寄存器的，因此最终干活的依然是寄存器。换句话说，栈架构相当于在寄存器架构的基础上为了便于迁移和理解加入了新的操作，自然就更长了)。

说栈架构比寄存器架构慢，上文给出的原因其实只是次要原因，更重要的是，栈并不是物理机实际提供的一个硬件，它只是存在于内存中的一个抽象概念。寄存器是距离CPU最近的存储单元，其次是缓存，然后才是内存。使用栈意味着指令中的那些出栈入栈其实都是CPU在与内存交互，尽管部分热点数据会进入缓存甚至寄存器，然而这无法从本质上解决问题，毕竟栈的主体依然还在内存中，而且频繁的内存-缓存-寄存器间数据的流动本身就是一项开销，因此栈架构比寄存器架构要慢很多。

# JVM的解释器的执行过程

既然说JVM是基于栈的指令集架构的，那么下面就具体说说其解释器的执行过程。

首先我们看一个小例子：

```
public class Test { 

    public int calc() {
        int a = 100;
        int b = 200;
        int c = 300;
        return (a + b) * c;
    }
}
```

然后我们用javap将这段代码反编译，我们只看其中的calc()方法的Code属性：

```
  public int calc();
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        100
         2: istore_1      
         3: sipush        200
         6: istore_2      
         7: sipush        300
        10: istore_3      
        11: iload_1       
        12: iload_2       
        13: iadd          
        14: iload_3       
        15: imul          
        16: ireturn       
```

这段信息首先告诉我们：

```
stack=2, locals=4, args_size=1
```

即操作数栈的最大深度为2，局部变量表的长度为4个Slot，传入参数个数为1(this)。

现在我们以如下7张图描述解释器的执行过程：

![1.png](/images/blog_pic/JVM/字节码解释执行引擎/1.png)

![2.png](/images/blog_pic/JVM/字节码解释执行引擎/2.png)

![3.png](/images/blog_pic/JVM/字节码解释执行引擎/3.png)

![4.png](/images/blog_pic/JVM/字节码解释执行引擎/4.png)

![5.png](/images/blog_pic/JVM/字节码解释执行引擎/5.png)

![6.png](/images/blog_pic/JVM/字节码解释执行引擎/6.png)

![7.png](/images/blog_pic/JVM/字节码解释执行引擎/7.png)

需要说明的是，上面的过程仅仅是理论上的概念模型，而大多数的JVM实现都会做一些优化来提高性能，因此实际运行起来通常不会与这个概念模型完全相同。其实更准确的说，主流JVM的实际情况会与这个概念模型的差别非常大。例如HotSpot的指令集中有很多以"fast_"开头的非标准字节码指令用于合并，替换输入的字节码以提升解释执行的性能。而对于即时编译器(JIT)而言，优化的手段就更加花样繁多了。