---
title: Java 设计模式-21.Proxy模式
date: 2018-09-05 15:34:49
tags: [Java,设计模式]
categories: Java 设计模式
---

在《图解设计模式》一书中，Proxy模式被归入了第9部分[避免浪费]()。在GoF原书中，Proxy模式则被归入了[结构型设计模式]()。

<!-- more -->

# 综述

在日常生活中，我们常会遇到如下类似的情况：

- 场景1：**消费者(角色1)**想买菜，于是他找到**商人(角色2)**，商人卖给消费者他从**菜农(角色3)**那收上来的菜。
- 场景2：**产品经理(角色2)**收集**用户(角色1)**的需求，将其汇总整理后提给**程序员(角色3)**。
- 场景3：**用户(角色1)**发现了产品的问题，于是他打电话给**客服(角色2)**，客服再将问题转交给**技术人员(角色3)**。

虽然场景不同，但是上述示例均由如下3个角色构成：

- 角色1：提出需求的人
- 角色2：将角色1的需求转交给角色3
- 角色3：实际完成需求的人

这么来看，角色二似乎是可有可无的。这也是为什么在古代商人一直遭人轻贱的重要原因之一。直至今日，也总会冒出下面这样的广告，试图甩掉角色2：

![0.jpg](/images/blog_pic/Java 设计模式/21Proxy模式/0.jpg)

那么实际上是这样的吗？

当然不是。

![1.jpg](/images/blog_pic/Java 设计模式/21Proxy模式/1.jpg)

客观的说，如果必须要在这3个角色中拿掉一个的话，那么还是会拿掉角色2。因为角色1与角色3构成了事件的根基，二者如果缺了任一个事件本身就进展不下去了，这也是为什么我们会觉得角色2可有可无的原因。但是如果如果没有角色2，角色1与角色3的沟通将异常艰难，也很难形成健康的关系。这就好比物质基础与精神追求哪一个对人更重要那样：如果硬要只能选一个的话，那肯定是物质基础，毕竟活下去是前提条件。但是如果成为一个健全的人，精神追求是必不可少的。

我们可以具体分析一下角色2的作用。在上述需求中，角色3作为实际需求的处理者，往往不愿意，或者说是没能力直接对接角色1。我们以场景2为例。假如没有了产品经理，客户直接与程序员对接。那么在客户看来，我就只是说加一个按钮，面前这个家伙就神神叨叨的说了一大堆自己听不懂的专业名词；而在程序员看来，面前的这家伙就是个SB，提的都是什么智障需求，感觉做什么似乎都很容易。换句话说，我们需要这样一个角色，他既能听懂程序员在说什么，也知道说什么客户能听懂，这自然就是角色2，产品经理啦。

不仅如此，在所有场景中，角色1一般都是远多于角色3的。而每个角色1的需求又总会略有不同。如果角色1与角色3直接碰面。那么角色3就不得不面对形形色色的需求。但实际上，角色3通常都只会完成一个或者至多几个原型，将哪个原型交给哪个角色1，或者是将哪个原型微调1下交给角色1，这又是角色2的工作了。

简单来说，虽然角色3最终的目的是为角色1服务，但是在具体的需求中，角色3通常是无法面面俱到考虑到角色1所有的需求的。此时就需要角色2，也就是代理登场了。角色1与角色3完成了解耦，而角色2则承担起了代理人的作用。

由此，演化出来的设计模式就是Proxy模式。

说到这里，我们很容易就会想到另一个设计模式：[2.Adapter模式]()。在Adapter模式中，也有如下3个角色：

- 角色1：需要数据
- 角色2：转换数据格式以适配
- 角色3：提供数据

这样看来，二者确实极为接近。不过，二者最本质的不同在于角色2，也就是各自的核心角色。在Adapter模式中，角色2被称为适配器，它只承载很简单的转换的功能，我们以显示器通过适配器连接主机为例，显示器(角色1)很明确最终数据还是主机(角色3)提供的，只不过格式对不上，因此需要适配器(角色2)转换一下，此时，角色2只是一个小小的原件。而在Proxy模式中，角色2被称为代理，顾名思义，在角色1看来，角色3仿佛是不存在的。或者说，角色2就是角色3。举个例子，作为消费者(角色1)，当我们向菜贩(角色2)买菜时，我们根本不会关心菜到底是哪个菜农(角色3)种的。

不仅如此，适配器仅仅只是在转换数据，不具有任何制造数据的能力。而在代理存在的场景中，角色1的核心需求由角色3完成。这意味着，对于一些不那么核心的需求而言，代理则无需麻烦角色3。以上文的场景3为例，客服并不会将用户所有的投诉都反馈给技术人员，对于那些明显简单或者明显逗逼的投诉客服自己就会处理掉 -- 这是非常重要的，正如我们前文讲到的，在应用代理的场景下，角色1的数量往往远多于角色3。代理的这种能力能够在很大程度上缓解角色3的压力。

# 示例程序

下面我们来看一个应用了Proxy模式的小例子。该程序会通过代理(角色2)为调用者(角色1)找到工人(角色3)。首先是类图：

![2.jpg](/images/blog_pic/Java 设计模式/21Proxy模式/2.jpg)

本程序中的所有代码将被统一置于design21包下，结构如下：

![3.jpg](/images/blog_pic/Java 设计模式/21Proxy模式/3.jpg)

下面将逐个贴出每个类的源码。

**Workable接口**

```
package design21;

public interface Workable {

    String getType();

    void work();
}
```

**Worker类**

```
package design21;

public class Worker implements Workable {

    private String type;

    Worker(String type) {
        this.type = type;
    }

    @Override
    public String getType() {
        return this.type;
    }

    @Override
    public void work() {
        System.out.println(this.type + "在工作");
    }
}
```

**WorkerProxy类**

```
package design21;

public class WorkerProxy implements Workable {

    private Worker worker;

    private String type;

    public WorkerProxy(String type) {
        this.type = type;
    }

    @Override
    public String getType() {
        return this.type;
    }

    @Override
    public void work() {
        if (null == worker) this.worker = new Worker(this.type);
        this.worker.work();
    }
}
```

**Main类**

```
package design21;

public class Main {

    public static void main(String[] args) {
        Workable worker = new WorkerProxy("水暖工");
        System.out.println(worker.getType());
        worker.work();
    }
}
```

执行后，输出：

```
水暖工
水暖工在工作
```

代码整体比较简单，不过还是有如下几点需要说明一下，大家可以对照着前文的综述加深理解。

本程序中，Main类是角色1，WorkerProxy类是角色2，而Worker类则是角色3。剩下的Workable接口则是抽象WorkerProxy与Worker后得到的。如果仅讨论Proxy模式最核心的功能，那么是不需要Workable，此时Main只能感知得到WorkerProxy。而在引入了Workable之后(通常我们都是会引入的)，Main连WorkerProxy都无需感知了。在示例程序中，WorkerProxy实例是在main方法中new出来的，这可能会给大家造成误解，不过在更常见的场景中，这个Workable应该是作为参数传递给角色1的，角色1根本不需要也不想要了解这个Workable到底是什么：这确实很合乎逻辑，对于调用者而言，他要的就是一个工人，或者更具体的来说，他要的不是工人，他要的是工作被完成。所以对调用者而言，其实他根部不在意这个Workable具体是个啥，到底做了啥，什么代理，什么委托，和调用者都没半毛钱的关系。因此抽象出Workable可以将调用者很好的与其他的角色解耦。

然后是问题二，调用者只需要一个Workable我们已经理解了。但是为什么要让WorkerProxy与Worker均实现Workable呢？换句话说，代理是代理，工人是工人。为什么要让角色2与角色3实现相同的接口呢？

这样的好处在于，代理与工人因此就具备了统一性。从逻辑上讲，对于调用者而言，为他服务的这个Workable其实只有一个身份："能帮助自己完成工作的人"。至于这个人是自己亲自做还是委托给他人调用者并不在意，从这个角度来看，角色2与角色3的身份确实是统一的；从实际的代码结构来看，代理是可以分级的。换句话说，代理找到的并不一定是真正的工人，它还有可能是另一个代理，只要身份统一，它就可以扮演工人的角色。很显然，这是对[11.Composite模式]()的应用。

正因为如此，这种将WorkerProxy与Worker统一起来的方式也成为了Proxy模式的默认思路。只不过，这同样会产生一些问题。因为Workable是调用者需要的接口，换句话说，它内部约束的那些方法就是调用者提出的需要。让WorkerProxy实现这个接口倒没什么。但是让Worker直接暴露在调用者的需求下却不太妥当。正如前文分析过的，角色3通常只会生成少量的几个原型，代理有一个很重要的工作就是将这几个原型稍加修改从而适应千变万化的需求。因此某些场景下，我们也会将角色2与角色3严格分隔开。这样角色1提出的需求对于角色3而言就是完全透明的了。

对于Main而言，当new出WorkerProxy时，它就认为工人已经生成好了。但是实际上，直到work()方法被调用之前，其实都并没有真正的生成工人。这其中还包括一个worker.getType()，也就是说main还像模像样的获取了一下工人的类型。只不过，该功能其实是被代理直接完成了，并不需要真正的工人(还记得综述中那个客服的例子吗)，因此依然不需要生成工人。直到不生成不行，也就是要让工人工作的时候，代理才通过懒加载的方式创建了工人，而后委托工人工作。这样就对工人的生成尽可能的做出了推迟，在系统规模较大时，这种将操作尽量移出初始化的做法可以极大的减少系统的启动时间。

在本示例中，Worker是无需感知到WorkerProxy的，这是理所当然的。而WorkerProxy为了能够将工作委托给Worker，则必须能够感知得到Worker才行(示例程序将Worker加为了WorkerProxy的字段)，这在逻辑上也是说得通的。不过在实际应用中，为了进一步提高灵活性，角色2与角色3也会解耦，即代理也不会记录实际工作的人是谁。在需要实际工人时，我们传递一个一个标志给代理，告诉它："我要用这个工人！"。通常这会是一个表征类的字符串，然后代理会通过反射将其解析出来。这样的坏处在于：虽然将角色2与角色3进行了解耦，但需要在调用时由角色1告知角色2要用哪个角色3，无形中又将角色1与角色3耦合在了一起，所以其实是有利有弊。

# 登场角色

上面的示例程序介绍了Proxy模式的Java实现，下面咱们试着跳出语言层面，抽象出Proxy模式中登场的角色。

**Subject(主体功能)**

Subject抽象出了调用者的需求。Proxy与Real也因为Subject而具有了一致性。在示例程序中，由Workable接口扮演这个角色。

**Real(实际的工人)**

在示例程序中，由Worker类扮演这个角色。

**Proxy(代理人)**

在示例程序中，由WorkerProxy类扮演这个角色。

**Client(请求者)**

在示例程序中，由Main类扮演这个角色。

下面是抽象后，无关语言的类图：

![4.jpg](/images/blog_pic/Java 设计模式/21Proxy模式/4.jpg)

# HTTP代理

提到代理，我们很容易想到HTTP代理。HTTP代理是指位于HTTP服务器(Web服务器)和HTTP客户端(Web浏览器)之间的一组软件。我们可以把其看作是对Proxy模式的一种应用。其中，HTTP服务器是Real，HTTP代理是Proxy，Web浏览器则是Client。我们不妨以HTTP代理的缓存功能来说明一下。在我们通过Web浏览器访问Web页面时，并非每次都会真的去访问HTTP服务器，而是会先去获取HTTP代理缓存的页面，只有当没有缓存，缓存有更新或是缓存失效时才会真的去访问Web浏览器。

# 代理的各种形式

**Virtual Proxy(虚拟代理)**

本文介绍的Proxy模式及给出的示例采用的就是这种方式，也是最基本的代理。只有当真正需要实例时才会生成。

**Remote Proxy(远程代理)**

当Real角色处于网络远端时，Remote Proxy可以让我们仿佛使用本地实例那样使用它们。Java的RMI(Remote Method Invocation，远程方法调用)就是Remote Proxy的应用。

**Access Proxy**

较之普通的Proxy，Access Proxy引入了访问权限。即我们可以只允许指定的用户调用指定的方法。