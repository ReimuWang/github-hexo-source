---
title: Java 并发-Java内存模型
date: 2017-07-12 16:40:36
tags: [Java,并发]
categories: Java 并发
---

若CPU是多核架构的，本文中的1个CPU指CPU的一个核。

# 硬件内存架构

现代计算机硬件架构的简单图示：

![0.png](/images/blog_pic/Java 并发/Java内存模型/0.png)

绝大多数CPU都有一个缓存层，有些CPU还有多层缓存。

CPU操作数据时的数据流向：主存->缓存->寄存器->CPU读取并处理->寄存器->缓存-->主存。

主存<->缓存的数据：为提高执行频率，不会每有一次CPU对数据的操作就进行一次同步，而是会在某个时间点一次性同步一批。每次同步也不会刷新所有缓存区域，而是以cache lines为基本单位一次同步缓存区域的一部分。

<!-- more -->

# Java内存模型

硬件内存架构没有栈和堆的区分。随着与CPU当前执行指令的亲密度的降序排列栈和堆中的信息可能出现在硬件架构中的所有位置：寄存器->缓存->主存。

一个CPU同时只能处理一个Java线程。

为建立JVM与硬件架构之间的联系，产生了Java内存模型JMM(Java Memory Model)。JMM的关键技术点都是围绕着多线程的原子性(Atomicity)，可见性(Visibility)及有序性(Ordering)建立的。

**原子性(Atomicity)**

原子性的操作是指那些最基本的，不可再分的操作，即便是在并发环境中，也不会产生模糊的值。例如两个线程各占用一个CPU同时给一个int型的变量赋值。线程1欲赋值为1，线程2欲赋值为2。那么结果上这个变量的值要么是1，要么是2，而绝不会产生某个其他的中间值。

举一个反例，在32位的JVM上，长度为64位的long型数据的读和写都不是原子操作(仅仅是32位的JVM是这样，64位的JVM对long型的操作也是原子的)。可以理解为都是先操作其前32位，再操作其后32位。每次操作32位的这个操作是原子的，但是两次这样的原子操作所拼接成的64位的long型数据的操作就不是原子的了。这就会带来一系列的并发问题。

具体来说，不妨设有一个long型的变量l，其前32位的值为i1，后32位的值为i2。则有l=i1+i2(此处的+是拼接)。再假设有写入线程1及写入线程2对l做并发修改。若某修改顺序为：线程1修改i1 --> 线程2修改i1 --> 线程2修改i2 --> 线程1修改i2。这样得到的结果l中的i1部分是被线程2修改的，i2部分是被线程1修改的，产生了既不是线程1也不是线程2所期望的一个脏值。

**可见性(Visibility)**

可见性问题主要包含如下两种：

1. 自身的修改能否及时被他人所见：CPU经由其缓存对数据做出的修改只要没有同步回主存就无法被其他CPU所见。

2. 能否及时看到他人的修改：缓存只要没有从主存中同步那么CPU就拿不到主存当前的最新值。

解决策略：Java中的volatile关键字可以保证所有被其修饰的变量：

1. 修改后总可及时同步回主存。

2. 读取时总可读取到主存中的最新值。

---

竞争条件(race conditions)：即便保证了可见性，当多个CPU同时操作某数据时，依然会产生并发问题：

1. 缓存1读取最新的o，缓存2读取最新的o：此时没有问题。

2. 缓存1处理o，缓存2处理o：此时o的值在缓存1，缓存2，主存中已有差异。

即便是可以及时同步回主存，也是指CPU对o的操作告一段落后，因此这个同步的操作总是能分出先后，后同步回主存的值会把先同步回主存的值覆盖掉。

解决策略：Java synchronized同步，详见[Java 并发-synchronized](/2017/07/13/Java 并发-synchronized/)。

**有序性(Ordering)**

为了提高执行效率，保证流水线尽量满载(即尽量少的中断流水线)，有时候可能会进行指令重排(注意仅仅是可能，何时重排，怎样重排，都是应用程序不可控的)。重排后可以保证在线程内部不会因重排而导致结果有变化，但是对于并发环境下其他线程的观测结果重排则不做保证。例如：

```
public class Test {

    private int a;

    private boolean flag;

    public void write() {
        this.a = 1;
        this.flag = true;
    }

    public void read() {
        if (this.flag) System.out.println(this.a);
    }
}
```

现让线程1调用write()方法，先执行。线程2调用read()方法，稍晚执行。理论上结果要么是1(read()方法执行时write()方法已执行完成)，要么无输出(read()方法执行时write()方法还未执行到this.flag = true)。但是如果发生了指令重排且指令重排的结果将write()方法改变为如下所示：

```
public void write() {
    this.flag = true;
    this.a = 1;
}
```

对于调用write()方法的线程1而言，这样排列对结果没有任何影响。但是对线程2而言，flag先于a被设置会导致输出的结果可能为0。

解决策略：volatile可阻止被其修饰的变量的上下文中发生指令重排。

指令重排遵循Happen-Before规则，具体来说：

- 程序顺序原则：一个线程的内部要保证语义的串行性。

- volatile规则：volatile变量的写先发生于读，这保证了volatile变量的可见性。

- 锁规则：解锁(unlock)必然发生在随后的加锁(lock)前。

- 传递性：A先于B，B先于C，那么A必然先于C。

- 线程的start()方法先于它的每一个动作。

- 线程的所有操作先于线程的终结(thread.join())。

- 线程的中断(interrupt())先于被中断线程的代码。

- 对象的构造函数先于其finalize()。

# Java内存模型中的变量位置

方法的局部变量存放在栈上。对象存放在堆上：

属于方法的局部变量：标记变量的空间位于栈上其所属方法的栈帧中。

属于对象的非静态成员变量：标记变量的空间位于堆上其所属的对象中。

属于类的静态成员变量：标记变量的空间位于堆上其所属的类定义对象(即该类的Class对象。该对象的信息来源于方法区)中。

对于 属于方法的局部变量/属于对象的非静态成员变量/属于类的静态成员变量 ，均有：

若为基本数据类型，标记变量的空间中的值即为其本体。

若为非基本数据类型，标记变量的空间中的值为本体的引用，本体为堆上的对象。