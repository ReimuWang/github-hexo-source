---
title: Java 设计模式-UML
date: 2018-06-04 17:53:49
tags: [Java,设计模式,UML]
categories: Java 设计模式
---

# 什么是UML

UML(Unified Modeling Language，即统一建模语言)是让系统可视化，让规格和设计文档化的表现方法。

通常我们会用UML来描述设计模式中类和接口的关系。本文将使用Java语言为例来介绍UML，因此本文出现的术语其实都是Java中的术语，而非原生的，无关语言特性的标准UML术语。例如我们会用Java中的字段(field)取代UML中的属性(attribute)，用Java中的方法(method)取代UML中的操作(operation)。

<!-- more -->

# 类图

UML中的类图(Class Diagram)用于表示类与接口之间的静态关系。虽然名字叫作类图，但是类图中并不只有类。

**类与层次结构**

首先，我们来看一段示例代码：

```
abstract class ParentClass {

    int field1;

    static char field2;

    abstract void methodA();

    double methodB() {return 0.0;}
}

class ChildClass extends ParentClass {

    @Override
    void methodA() {}

    static void methodC() {}
}
```

然后，我们给出它所对应的类图：

![0.jpg](/images/blog_pic/Java 设计模式/UML/0.jpg)

该图展示了ParentClass与ChildClass两个类之间的关系，其中的空心箭头表明了两者之间的层次关系：箭头由子类指向父类。换言之，这是表示继承(extends)的箭头，即表示ParentClass是ChildClass的父类。之所以箭头方向是从子类指向父类，实际上表示的是一种继承的感知：子类继承父类，说明子类在父类的下层，那么子类一定要能感知到父类才行，反映到图上就是子类能通过箭头的指引找到父类。相反，父类作为上层类并不需要感知到子类的存在。

图中的长方形表示类。长方形内部被两条线段自上至下分为了3部分：

1. 类名
2. 字段名
3. 方法名

因为ChildClass中没有定义新的字段，因此它的第二部分是空的。

有时，表示类的长方形中还会写出其他信息(可见性，方法的参数个数参数顺序参数类型等)。在最为严谨的场合下，类图与代码是一一对应的：即我们可以通过类图无歧义的生成唯一的一份代码。不过通常，我们绘制UML只是为了说明代码的结构关系，并不需要表示的那么详细，因此都会做出一些删减。我们给出的实例采用的是最为精简的模式，即只提供了必需要有的那3个基本信息(类名，字段名，方法名)，没有附加任何其他信息。当然，这个时候我们就无法基于这张类图还原出源代码了。

关于这3个基本信息，我们还有一些更为详细的设定：

- 虽然官方并没有明确设定，但是通常，我们都会将类名加粗表示，例如图中的ParentClass，ChildClass。
- 所有抽象的(即被abstract所修饰的)元素都以斜体表示。例如抽象类ParentClass，抽象方法methodA。
- 所有静态的(即被static所修饰的)元素都会加上下划线。例如静态字段field2，静态方法methodC。
- 父类的字段与方法，只要没在子类中被修改或重写，就无需在子类中再写一遍(对于字段而言，只要不是在字段声明时修改就不算修改)。

前文已经提到了，本文在介绍UML时，使用的是Java的术语，而非UML规范中无关语言的通用的术语。事实上，每个语言都会有自身的术语，例如Java中的字段在C++中被称为成员变量(其实Java中也可以这样叫啦，毕竟Java算是脱胎自C++)，Java中的方法在C++中被称为成员函数。

**接口与实现**

下面我们继续来看下一段示例代码：

```
interface Printable {

    int FIELD1 = 1;

    void method1();
}

class PrintClass implements Printable {

    @Override
    public void method1() {}
}
```

然后给出它的类图：

![1.jpg](/images/blog_pic/Java 设计模式/UML/1.jpg)

上例描述的是实现接口的类图。对于接口而言，它与前文介绍的类的类图有很多相似之处：

- 以长方形表示接口，和类一样，内部也以两条横线分为3部分：接口名，字段名，方法名。
- 虽然官方并没有明确设定，但是通常，我们都会将接口名加粗表示。
- 接口名上方会默认添加&lt;&lt;interface&gt;&gt;以表示这是一个接口。
- 接口默认隐含了修饰符abstract。因此如果严格来说，接口名都应该是斜体的。不过由于这是所有接口都有的特性，所以有时候也会不使用斜体。通常我们会保留斜体。上例类图中我们就是这么做的。
- 虚线空心箭头表示PrintClass实现了接口Printable。箭头之所以是从实现类指向接口的原因与前文介绍的类在继承时箭头的方向的原因类似：实现类必须能感知到它所要实现的接口才行，反映到类图中就是实现类可以顺着箭头的方向找到它欲实现的接口。而接口则不需要知道哪些类实现了它。
- 接口中的字段默认隐含了修饰符public static final，而接口中的方法则默认隐含了public abstract。因此如果严格来说，字段都应被加上下划线，而方法都应是斜体的。不过依然因为这是所有接口都遵循的规则，因此有时也会不应用下划线或斜体。比如上例中我们保留了斜体，省略了下划线(因为下划线看着挺乱的。其实，在可以省略的情况下，我们一般都会保留斜体，而省略下划线)。
- 与继承的定义类似，接口中定义的方法需在实现类的长方形中再写一遍，因为实现类会重写接口中定义的方法(除非实现类是抽象类，方法是抽象方法，此时较之接口相当于依然没有发生变化，不用在实现类中重写)。而接口中的字段因为是final的，则无需在实现类中再次书写。

**聚合**

看下一段代码：

```
class Color {}

class Fruit {

    Color color;
}

class Basket {

    Fruit[] fruits;
}
```

就算没有文档，这段代码所要表达的含义也是一目了然的：篮子里装了好多个水果，每个水果都有其自身的颜色。它可能的一种类图如下：

![2.jpg](/images/blog_pic/Java 设计模式/UML/2.jpg)

首先借用本例补充一个小知识点：如果某类或接口中没有任何需要记录的字段或方法，那么就可以省略那两道横线，一如本例中的Color(事实上，Color作为Java API中的类，其中自然会有很多内容，但它们却不是本类图需要关注的，因此均被省略)。

前文介绍的类与接口之间的关系(继承，实现)是在系统中有强约束且唯一的。而本小节所介绍的聚合(aggregation)则更多表现的是一种逻辑与思路上的关系，它不再表示从属，其表示的是"持有"。同样一段代码，依想表述重点的不同，可以画出很多种表示不同聚合关系的类图。在上例中，聚合关系其实只有一种：篮子-水果-颜色。但实际上，篮子里可能不止有水果，Basket类中可能还有一个字段叫toys，顺着这条聚合的线，我们可以导出一条完全不同的聚合线路：篮子-玩具-材料。我们画类图是为了介绍代码，而每次介绍其实并不需要介绍全貌，而只是根据需求介绍听者感兴趣的部分，这意味着，也许我们只需要画其中一条聚合线的类图就足够了。这样就可以抛除掉本次叙述不关心的点，使得讲解更易于理解。

也就是说，聚合可供发挥的空间其实很大，我们可以根据需求自由的画出类图，从自己的角度去理解和分析代码，阐述自身的观点。

我们使用空心菱形为起点的箭头表示聚合，假如A持有B，那么箭头的方向就是自A指向B。其箭头方向的缘由与前文一脉相承：A持有B，那么A就要能够顺着箭头的方向找到B才行，反之，B作为被持有者，则无需知道A的存在。

**可见性(访问控制)**

看下一段代码吧DAZE~：

```
class Something {

    private int privateField;

    int packageField;

    protected int protectedField;

    public int publicField;

    private void privateMethod() {}

    void packageMethod() {}

    protected void protectedMethod() {}

    public void publicMethod() {}
}
```

这段代码的类图为：

![3.jpg](/images/blog_pic/Java 设计模式/UML/3.jpg)

该图主要展示了类图对于可见性的标记方式：

![4.jpg](/images/blog_pic/Java 设计模式/UML/4.jpg)

接口中的字段与方法均隐含了(且只能是)默认的访问权限(public)，因此我们通常不会在类图中显式指定。

**内部类**

Java语法允许内部类的存在，此时基本的类图将再多出一格，最后一格描述内部类。先来看示例代码：

```
class Out {

    private class In {}
}
```

它的类图为：

![5.jpg](/images/blog_pic/Java 设计模式/UML/5.jpg)

如图所示，内部类的描述被置于外部类的第四部分。同时我们用一条起点为圆圈十字线的箭头由外部类指向内部类。

通常，为了使得内部类的所属能看得更清楚，我们在叙述内部类的类名时，会采用"外部类$内部类"的方式。形如本例中的"Out$In"。

**字段与方法的详细描述**

在前面的例子中，当我们记述字段与方法时，只描述了它们的名称。这往往是不够的(不过在画一些无关语言的伪代码性质的类图时够用了，而且那种情况下基本也画不出更具体的东西)，尤其对于方法而言，这样是无法分辨重载方法的。因此，在多数时候，我们都需要记述更详细的信息。

下面来看一个例子：

```
class Something {

    private int privateField;

    public Something(char ch) {}

    double packageMethod(int i, String s) {
        return 0.0;
    }

    private void privateMethod(String str) {}
}
```

它的类图为：

![6.jpg](/images/blog_pic/Java 设计模式/UML/6.jpg)

有如下几点说明：

- 构造函数出现在方法的最前边，它们默认与类名相同，因此无需写方法名。且因其没有返回值，也不需要在最后补上冒号及返回值。
- 若方法的返回值为void，则只需在最后写上冒号即可。

**包继承关系**

首先来看代码：

```
package com.test;

public class Test {}
```

如果想要表达Test.java在test包内，那么可以这样来画类图：

![7.jpg](/images/blog_pic/Java 设计模式/UML/7.jpg)

**类的关联**

上文中我们介绍了聚合，这其实已经是一种很灵活的类图绘制方法了，不过此时我们依然还是基于代码的。其实UML还为我们提供了更为灵活的描述类之间关系的方式，例如：

---

Client使用Target：

![8.jpg](/images/blog_pic/Java 设计模式/UML/8.jpg)

---

Factory生成Product：

![9.jpg](/images/blog_pic/Java 设计模式/UML/9.jpg)

---

Subject向Observer发送消息：

![10.jpg](/images/blog_pic/Java 设计模式/UML/10.jpg)

---

这种类图引入了更多的文字描述，可以表述的含义也更为丰富。其中黑色的实心三角代表了文字关系的传递方向。以"Client使用Target"为例，小三角与箭头均是自Client指向Target。

# 时序图

UML的时序图(sequence diagram)用来表示程序在工作时其内部方法的调用顺序，以及事件的发生顺序。

类图描述的是"不因时间流逝而发生变化的关系"，也就是所谓的"静态关系"。而时序图则恰恰相反，它描述的是"随时间发生变化的东西"，也就是所谓的"动态行为"。

依然先来看代码：

```
class Client {

    Server server;

    void work() {
        this.server.open();
        this.server.print("ReimuWang");
        this.server.close();
    }
}

class Server {

    Device device;

    void open() {}

    void print(String s) {
        this.device.write(s);
    }

    void close() {}
}

class Device {

    void write(String s) {}
}
```

该代码模拟了一个非常简单的客户端请求服务端，服务端进而请求底层设备输出一句话的功能。它的时序图如下所示：

![11.jpg](/images/blog_pic/Java 设计模式/UML/11.jpg)

最上方的3个长方形表示实例。从本质上来说，时序图描述的其实就是实例随着时间推进做出的行为。实例中的信息都会加上下划线。而通常来说，实例的描述格式为：

```
实例名:类名
```

上图采用的就是这种标准的格式。当然啦，实例名仅仅只是一个名字而已，其实并没有那么重要，因此很多时候我们也会不记录实例名，变为：

```
:类名
```

如果用这种简化的规则的话，那么上图变为：

![12.jpg](/images/blog_pic/Java 设计模式/UML/12.jpg)

每个实例都会有一条自其下边起始，纵向垂直向下延伸的虚线段，在UML中，这条虚线被称为"生命线"。顾名思义，实例将随着虚线的出现而诞生，随着虚线的停止而死亡。

现在就颇有一些AOP的意味在其中了：很显然，由于生命线的这种设定规则，时间的流逝方向将是垂直向下的。水平线则表示某个时间点上发生的事件。

阅读时序图时，我们不妨将其想象为动态的，即将生命线想象为时间本身，随着它垂直自上而下流动来阅读时序图。在生命线流动过程中，可能会变为细长的矩形，实例处于细长矩形状态时表明实例正在进行某种活动，比如正在执行实例中的某个方法等。一旦活动结束，实例的生命线将脱离细长矩形的状态，恢复虚线状态。

了解了大致的规则后，我们不妨按照时间流逝的顺序读一下上例中的时序图。

首先，实例client因其方法work()被调用进入活跃状态，如图所示，方法的调用将采用水平的实线表示，箭头方向指向生命线，实线上仅写了方法名。方法调用后，实例client立刻进入细长矩形状态，直到图的最下端细长矩形结束，表示work()方法退出，实例client的生命线又恢复为虚线状态。在细长矩形结束时，会绘制一条水平虚线，表明方法的退出。虚线的箭头将从生命线向外指出。

在work()方法调用期间，具体又发生了以下事件：

1. server实例的open()方法被调用，相应的，server实例的生命线马上转为细长矩形状态，open()方法执行完后又转回虚线状态。

2. server实例的print()方法被调用，而其内部又调用了device实例的write()方法。

3. server实例的close()方法被调用。

最后需要说明的是，表示方法返回的水平虚线箭头其实是可以省略的，因为它和表示方法调用的水平实线箭头不同，水平实线箭头上是会写明方法名称的，而水平虚线箭头除了虚线本身之外不会附加任何信息，而纯粹从逻辑需求来讲，这条虚线其实是不用存在的：实例的生命线自细长矩形状态变回虚线状态自然就说明方法退出了，它仅会起到一个对齐的视觉效果。因此，在要求不严谨，或是图很复杂，不想那么多线看着心烦时，不画这条水平虚线也是很常见的。