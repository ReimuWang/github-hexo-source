---
title: JVM-垃圾收集
date: 2017-10-26 15:04:49
tags: [Java,JVM,GC]
categories: JVM
---

# 垃圾收集的历史

垃圾收集(Garbage Collection, GC)的历史比Java要久远，只是因为近年来Java的高歌猛进让人们产生了一种"GC是Java的产物"的错觉。实际上1960年诞生于MIT的Lisp才是第一门使用内存动态分配及垃圾收集技术的语言。

<!-- more -->

# 哪些区域需要进行GC？

- 程序计数器(Program Counter Register)：线程私有，小到不会抛出内存溢出异常，无需垃圾收集。
- 虚拟机栈(Virtual Machine Stack)：线程私有，栈中的元素为栈帧，一个栈帧代表线程调用的一个方法。栈帧的大小在编译期就已基本确定(运行期JIT可能会做出一些优化)，方法执行完成栈帧随之销毁，无需垃圾回收。
- 本地方法栈(Native Method Stack)：同虚拟机栈。
- 堆(Heap)：线程间共享。特定类型的对象的大小是固定的，然而编译期只能确定静态类型，实际类型要到运行期才能确定，因此对象的大小到运行期才能确定，即需要在运行时动态分配内存，需垃圾收集。
- 方法区(Method Area)：线程间共享。类的装载及卸载都是在运行期动态进行的，需垃圾收集。

从广义上讲，JVM回收虚拟机栈及本地方法栈的内存也是垃圾收集，只是这部分收集的逻辑简单明了，无需一个复杂的机制来支撑。因此垃圾收集通常是指对运行时动态分配的那部分内存的回收。进而，内存动态分配与垃圾收集往往是成对出现的：内存动态分配迫使垃圾收集的复杂化。

# 如何判断堆中的哪些对象是垃圾？

判断方法有2：

- 引用计数算法(Reference Counting)
- 可达性分析算法(Reachability Analysis)

**引用计数算法**

描述：给每个对象都配备一个引用计数器，每当有一个地方引用它，计数值加1。每当一个引用失效，计数值减1。任何时刻计数值为0的对象就是垃圾。

优点：简单粗暴，判断效率高。

使用案例：微软的COM(Component Object Model)技术，使用ActionScript3的FlashPlayer，Python，在游戏脚本领域被广泛应用的Squirrel。

缺点：难以解决对象间的相互循环引用问题。依对象间的引用关系我们可以将堆中的对象划分为复数张图。当某张图中只有一个点(即没有其他地方引用该对象)，本算法是可以正确判断其为垃圾的，但是若某张图中有复数个点，而这些点全部是垃圾，本算法就很难将这些点均正确判为垃圾。

**可达性分析算法**

主流的JVM(C#及Lisp等主流商用程序语言也多采用本算法)均采用本算法来判断堆中的垃圾对象。

既然引用计数算法的缺陷在于某张图中有复数个点，且这些点全部为垃圾时难以判断，那么可达性分析算法就人为的设定几个"带头大哥"，告诉JVM没有带头大哥存在的图中的点均为垃圾。即带头大哥不可达的点是垃圾。

这些带头大哥被称为GC Root，GC Root在搜索点时所走过的路径被称为引用链(Reference Chain)。

那么如何筛选带头大哥呢？首要标准自然就是正在被使用着的对象，再次浏览JVM所管理的内存区域：

- 程序计数器(Program Counter Register)：没有对象引用，不会存在带头大哥。
- 虚拟机栈(Virtual Machine Stack)：栈帧的本地变量表(执行上下文)中引用的对象为带头大哥。
- 本地方法栈(Native Method Stack)：JNI(Java Native Interface，即Native方法)引用的对象为带头大哥。
- 堆(Heap)：欲被回收的区域，无法筛选出带头大哥。
- 方法区(Method Area)：常量或类静态属性(全局性引用)引用的对象为带头大哥。

例如，如下代码中对象a,b相互持有对方的引用，随后将a，b引用的位置置为空(即中断对象与GC ROOT间的可达性联系)：

```
public class Test {

    private Test reference = null;

    /**
     * 占据2MB空间。使垃圾收集的效果更为明显
     */
    private byte[] bigSize = new byte[2 * 1024 * 1024];

    /**
     * -XX:+PrintGCDetails
     */
    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.reference = b;
        b.reference = a;
        a = null;
        b = null;
        System.gc();
    }
}
```

运行结果：

```
[GC [PSYoungGen: 5427K->536K(38400K)] 5427K->536K(124416K), 0.0090463 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 
[Full GC [PSYoungGen: 536K->0K(38400K)] [ParOldGen: 0K->468K(86016K)] 536K->468K(124416K) [PSPermGen: 2563K->2562K(21504K)], 0.0120810 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 38400K, used 998K [0x00000007d5d00000, 0x00000007d8780000, 0x0000000800000000)
  eden space 33280K, 3% used [0x00000007d5d00000,0x00000007d5df9a60,0x00000007d7d80000)
  from space 5120K, 0% used [0x00000007d7d80000,0x00000007d7d80000,0x00000007d8280000)
  to   space 5120K, 0% used [0x00000007d8280000,0x00000007d8280000,0x00000007d8780000)
 ParOldGen       total 86016K, used 468K [0x0000000781800000, 0x0000000786c00000, 0x00000007d5d00000)
  object space 86016K, 0% used [0x0000000781800000,0x0000000781875228,0x0000000786c00000)
 PSPermGen       total 21504K, used 2569K [0x000000077c600000, 0x000000077db00000, 0x0000000781800000)
  object space 21504K, 11% used [0x000000077c600000,0x000000077c8826b8,0x000000077db00000)
```

很明显，GC前本来是存在于年轻代的大小合计大概是4MB的两个对象已被GC回收。

**建立对象间的联系：引用**

无论是引用计数算法亦或是可达性分析算法，都以对象为点连接成图。而进行连接的线即为引用。

在JDK1.1时，Java中关于引用的定义传统而又纯粹：若某内存区域中存储的数值代表另一块内存区域的起始地址，则这块内存区域代表着一个引用，其类型为引用类型。这种定义下，从引用关系的角度划分，对象的身份只有两个：引用者及被引用者。我们无法建立更为复杂的引用关系，例如：某些引用关系虽然并非是没有，但是并没有那么重要。即当内存充足时，该引用代表一个正常的引用。当内存吃紧时，该引用可以忽略。

因此，从JDK1.2起，Java将引用的概念扩充为4种，强度从强至弱依次为：

1. **强引用(Strong Reference)**：即为JDK1.1中的传统意义上的引用。程序中绝大多数的引用(诸如Object o = new Object())均是强引用。垃圾收集器绝不会收集通过强引用可达GC ROOT的对象。
2. **软引用(Soft Reference)**：使用SoftReference类实现。该引用即为前文"例如"所描述的那种引用：当某次垃圾收集后内存依然不够用，会进行第二次垃圾收集，此次收集将无视软引用。
3. **弱引用(Weak Reference)**：使用WeakReference类实现。也就是所谓的"消耗性引用"：经过一次垃圾收集后，该引用即失效。
4. **虚引用(Phantom Reference)**：使用PhantomReference类实现。又名幽灵引用或幻影引用。该引用并不是一个真正的引用，也无法在可达性计算中发挥任何作用，其存在价值仅仅为对象被回收后能发出一个系统通知。

# 对象逃避被回收的手段

通过可达性分析算法被标记为垃圾的对象仅仅只是被打上了一个垃圾的标记，并没有真正的被回收。在垃圾收集器真正动手之前，该对象还有最后一次死里逃生的机会：若对象重写了finalize()方法且该实例方法并未被调用过，则该对象会被放置到一个叫F-Queue的队列中。JVM会在合适的时机自动创建一个低优先级的Finalizer线程执行F-Queue队列中的方法。为了避免因finalize()方法执行得过慢甚至于死循环导致F-Queue中后续的方法无法执行甚至内存回收系统的崩溃，JVM并不承诺一定会等待finalize()方法执行完成，一旦超过其容忍限度JVM会强制终止方法的运行。

之所以说finalize()是对象最后一次死里逃生的机会，是因为对象可以在其finalize()方法中重新与GC ROOT建立可达性关系。垃圾收集器会对F-Queue中已执行完finalize()的对象重新进行可达性标记，若此时对象成功的与GC ROOT建立了可达性联系，则可逃脱被回收的命运。

因为每个对象的finalize()方法最多只会被JVM调用一次，因此这种自救机会最多也只有一次。

下面是一个被标记为垃圾的对象自救的小例子：

```
public class Test {

    /**
     * 垃圾对象与GC ROOT之间重新建立可达性联系的救命稻草
     */
    private static Test STRAW;

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize() 被调用");
        Test.STRAW = this;
    }

    public static void main(String[] args) throws InterruptedException {
        Test.STRAW = new Test();

        Test.STRAW = null;
        System.gc();
        Thread.sleep(500);    // 确保finalize()执行完成
        if (null == Test.STRAW) {
            System.out.println("垃圾对象被回收");
        } else {
            System.out.println("垃圾对象未被回收");
        }

        // 完全相同的代码。但test无法再次通过finalize()自救了
        Test.STRAW = null;
        System.gc();
        Thread.sleep(500);
        if (null == Test.STRAW) {
            System.out.println("垃圾对象被回收");
        } else {
            System.out.println("垃圾对象未被回收");
        }
    }
}
```

输出：

```
finalize() 被调用
垃圾对象未被回收
垃圾对象被回收
```

值得特别说明的是，虽然上例中使用finalize()方法进行自救弥漫着悲壮的艺术色彩，但是却并不推荐大家在程序中使用finalize()方法。最好能在写代码时忘记这个方法。finalize()方法是Java在诞生之初为了照顾C/C++程序员而做出的妥协(人之常情，不是自己所习惯的就会下意识的认为是不对的)，它其实是没必要存在的，运行代价高昂且结果具有不确定性，使用try-finally可以做得更好。

# 如何判断方法区中哪些数据是垃圾？

JVM规范中并没有明确指明方法区的实现方式及是否需要进行垃圾收集。本文讨论的方法区为HotSpot VM在JDK1.7及此前的版本：方法区是以永久代的方式实现的，会进行垃圾收集。

在方法区中进行垃圾收集的性价比通常较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集通常可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。

永久代的垃圾收集主要回收两部分内容：

- **废弃常量**:类似于回收堆中的对象。以JDK1.6的字符串常量为例(此时字符串常量池尚在方法区中，它是在JDK1.7时被移至堆中的)，假设当前字符串常量池中有字符串"八云紫"，但是此时系统中已没有任何一个String型的变量引用该常量值。如果发生内存回收，且有必要的话，该常量值即会被从字符串常量池中清除。其他的符号引用类似。
- **无用的类**:同时满足如下3个条件可称之为"无用的类"：1.堆中不存在该类的实例。2.加载该类的ClassLoader已被回收。3.该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。注意即便同时满足这3个条件也仅仅只是被标记为了无用的类。并非必然会因此被清理。类的回收条件较之堆中的对象及方法区中的常量要苛刻得多。

# 垃圾收集算法

**标记-清除算法**

标记-清除(Mark-Sweep)算法是最基础的垃圾收集算法。如其名称所示，算法分为标记及清除两步：

- **标记**:扫描所有可能存在垃圾的区域(即上文所总结出的堆及方法区)并标记出其中的垃圾
- **清除**:待标记完成后，统一回收垃圾

如下图所示：

![0.jpg](/images/blog_pic/JVM/垃圾收集/0.jpg)

其不足主要体现为两点：

1. 效率低下：每次垃圾回收都需要扫描所有可能产生垃圾的内存区域，且清理时需要跳跃式的一小块一小块的清理
2. 会产生内存碎片

**复制算法**

以堆为例，复制(Copying)算法：将堆分为了相等的两块(不妨命名为区域1及区域2)。每次只使用其中的一块。

不妨模拟一种情境：区域1正在使用，区域2闲置。当区域1装满后:

1. 标记区域1中的垃圾
2. 将区域1中仍存活的对象复制到区域2
3. 将区域1清空

进行完上述3步后，区域1及区域2的功能发生了交换：区域2变为了正在使用的区域，区域1闲置。并一直循环下去。

较之标记清除算法，复制算法的改进为：

- 效率有所提升，清理时直接将某一区域清空即可，简单高效
- 不会产生内存碎片：复制后的对象仍然是紧密相邻的

但是复制算法的缺点也是致命的：可用内存缩小为了原来的一半。

**改进的复制算法**

IBM公司的研究表明，正常的应用中98%的对象都是朝生夕死，即出生后基本连一次垃圾收集都挺不住。因此其实在复制算法中，闲置的区域通常并不需要一半那么大(这其实是最坏的情况，某区域满了且进行垃圾收集后什么都没清理掉)，每次清理后通常只有极为少量的对象能幸存下来。

基于此，可对复制算法的内存划分做出调整，整体上划分为如下两个区域：

- **Eden区**:语源为圣经中的伊甸园，即对象诞生的地方
- **Survivor区**:幸存者区，即挺过至少一次垃圾收集后的幸存对象所处的区域。其承担了复制算法原有的复制功能，因此又将其分为相等的两块(不妨仍以区域1及区域2命名)。每次仅使用其中一块。

结合上文IBM公司的研究结果，显然，Eden要远大于Survivor才合理。HotSpot VM中Eden与Survivor的默认比例为8:2。而Survivor又要分为均等的两份，因此堆被划分为了8:1:1 3小份。

举一个具体的例子：初始时堆中为空。而后新创建的对象被加入Eden。当Eden被装满后，触发垃圾收集，将Eden中经过本次垃圾收集后依然存活的对象加入Survivor的区域1。而后清空Eden。这样新创建的对象又可以进入Eden，当Eden第二次装满后将再次触发垃圾收集，此时的收集区域为Eden及Survivor的区域1，而后将这两个区域中经过本次垃圾收集依然存活的对象加入Survivor的区域2。而后清空Eden及Survivor的区域1。此时Survivor的区域1及区域2的功能发生了互换，随后重复这个步骤。

改进的复制算法极大的弥补了普通的复制算法的缺陷：浪费的内存从50%下降为了10%，通常来说这已经是一个可接受的值了。

但是改进是有前提的：即90%的内存空间在经过垃圾收集后所幸存的对象应能被10%的内存空间所容纳。根据IBM公司的研究，通常情况下这是没问题的。但是若不是通常情况呢？此时明明尚有大量的内存空间(90%的区域)，却无法创建新的对象了。

举个现实中的例子，一个信誉良好的人是可以凭其信誉向银行贷款的，因为通常情况下该人具备还款能力。但如果不是通常情况呢？银行为了减少损失，往往需要贷款人提供担保，要么是担保人，要么是抵押物。总之就是在贷款人无法还款时担保应顶上。

JVM采取的也是类似的机制，名为分配担保(Handle Promotion)。因此此前我们说到的8:1:1的这块空间的内部结构不变，但不再占据所有的堆空间了，而将其统一命名为新生代(young generation)。相对的，它的保人被称为老年代(old/tenured generation)，Minor GC后将按优先顺序(主要是依据年龄)把Survivor无法容纳的对象移入老年代。

HotSpot VM在默认情况下新生代与老年代的比例为1:2(因为保人的实力自然应该雄厚一些)。

除了保人制度外，引入新生代与老年代的划分还可将垃圾收集进行细化，即分代收集(Generational Collection)。从概率论的角度来说，两个对象o1及o2，o1经过了m次垃圾收集依然幸存，而o2经过了n次垃圾收集依然幸存。若有m大于n，即在下一次垃圾收集到来时，o1依然存活的概率应比o2大，其大的幅度将与m大于n的幅度成正相关。

举一个实际的例子，文学作品中的妖怪往往是越长寿的越强力。这种描述其实颠倒了因果关系：不是因为长寿导致了强力，而是因为足够强力的妖怪才不容易死，长寿的可能才更大。所以实际上强力才是因，而长寿为果。

类比到垃圾收集机制中，若将对象看作上例中的"妖怪"，每经过一次垃圾收集看作涨了一岁(其实更像是在渡劫)，那么很显然若有两个对象，其一很长寿，其二刚诞生，那么在下一次垃圾收集到来时，自然是已经很长寿的对象活下去的概率更大。

因此，从效果最大化的角度来看(即每次垃圾收集时可收集的内存占扫描总内存的比例应尽可能的高)。对于新生代中对象的收集应频繁一些，这被称为Minor GC。而对老年代中的长寿对象的收集的频率应低一些，这被称为Major GC。

还有一个名词名为Full GC。指得是清理整个堆空间—包括年轻代和老年代。但Major GC之前往往(注意仅是往往，Parallel架构的收集器就有直接只进行Major GC的策略)都会进行至少一次的Minor GC，因此通常二者是相连的，所以多数情况下我们会将Full GC与Major GC视为同一个概念。

除了堆区外，Full GC还会顺带收集方法区。

模拟一个情境。Eden已满，触发Minor GC，幸存的对象超过了Survivor一个区的容纳能力，则按长者优先的原则将无法容纳的对象加入老年代。若此时老年代也已满，则触发Major GC回收老年代的空间。

除了Survivor无法容纳以外，对象还可以其他方式进入老年代：

- 足够长寿了。即使Survivor空间足够，反复试图收集那些足够长寿的对象也是在浪费时间。倒不如直接将它们移入老年代。HotSpot VM进入老年代的默认年龄为15岁
- 大对象。Survivor毕竟是一块较小的内存，因此占用内存空间巨大的大对象并不会进入Survivor，而是直接进入老年代

**标记-整理算法**

改进的复制算法采用老年代作为保人，其内存空间不足时会触发Major GC回收老年代的空间。那么具体的回收算法是什么呢？当然不能再是改进的复制算法了，因为采用该算法的话就要再整出个老老年代来作为老年代的保人，系统将变得更为复杂，且这种复杂是不值得的：老年代的回收频率本就不高。但是采用普通的复制算法其缺陷又过于明显：浪费了一半的空间不说，老年代的回收效率不高导致每次都需要复制大量的对象。

因此老年代可采用标记-清除算法，为避免其缺陷基于其又改进出了标记-整理(Mark-Compact)算法。其中标记与标记-清除算法相同。随后的整理则会将所有的存活对象向一端移动。而后清理掉后端边界以外的内存。这样便避免了内存碎片问题。

# Stop The World

所谓Stop The World(下文简称STW)即是指垃圾收集过程中停顿所有的除垃圾收集线程以外的一切线程：正如其字面意思所述，整个世界都静止了，只有垃圾收集线程在活动。

STW是必要的，因为垃圾收集器在分析垃圾时必须要在一个能保证一致性的快照中进行：这个快照中对象的引用关系不能在分析的过程中发生变化，否则分析结果的准确性就无从保证。

但STW的缺陷又是致命的。用户程序将会被强制的中断以等待垃圾收集的完成，在响应时间要求较高的场景里有时这种停顿是不可接受的。

为此，垃圾收集器的一个重要使命就是尽量的减少STW对用户程序的干扰，但是直至现在，所有的垃圾收集器(无论是新生代的，老年代的，抑或是不分代的)都无法完全消除STW，即便是号称几乎不会发生停顿的CMS也仅仅只能说是"几乎"，其在初始标记及重新标记时也必须STW。

**oopMap**

既然无法避免STW，那么只能让这个时间尽可能的短。而缩短这一时间的有效手段之一就是尽可能的减小搜索范围。这也是JVM采用准确式GC的原因。所谓准确式GC即是指垃圾收集器可以明确知道某块内存区域中到底是引用还是实际值。这样在枚举根节点时就可以不用搜索非引用的内存区域。

准确式GC依托于准确式内存管理(Exact Memory Management)。所谓准确式内存管理即是指JVM可以明确知道某内存空间存储的数据的类型是什么。例如可明确知道123456究竟是代表一个整数值还是一个引用的地址值。

HotSpot使用oopMap这个数据结构来实现准确式内存管理的功能。oopMap中存储了执行到某条指令时内存中各变量的类型。

**安全点**

为每一条指令都生成一个oopMap是最简单的方法：这样仅从枚举根节点的角度来看，线程就可以断在任意一条指令上。但是需要生成大量的oopMap，占用大量的额外空间。

因此，HotSpot VM只会为特定的指令生成oopMap，这些指令所处的位置被称为安全点(Safepoint)。当程序需要进行垃圾收集时，非垃圾收集线程只能在安全点上停顿(因为只能在安全点上枚举根节点。严格来说，不包括正在执行native代码的用户线程，因为native代码一般不会改变Java对象间的引用关系，因此没有必要特意挂起它们。只要保证在GC的过程中不让它们从native方法中离开即可。若需要读取oopMap从上一个安全点处读取即可)。

关于安全点的设置需要满足一个平衡：既不能因设置得过多而占用过大的额外内存，也不能因设置得过少而导致GC线程等待过久。选取的要点为两个安全点之间为一个相对完整的小模块，即：

1. 循环的末尾
2. 方法临返回前或调用方法的call指令后
3. 可能抛异常的位置

为确保STW发生时非垃圾收集线程都在安全点上，可采取的策略有两种：

- **抢先式中断(Preemptive Suspension)**:中断所有非垃圾收集线程，若发现某个线程未中断在安全点上则恢复线程，让其跑到安全点上后再次中断。
- **主动式中断(Voluntary Suspension)**：欲STW时将中断标志设为true。各非垃圾收集线程在运行时会主动去轮询这个标志。当发现其为true后即中断自身。轮询的位置为创建对象分配内存时及各安全点处。

HotSpot VM采用主动式中断(现在几乎已经没有JVM采用抢先式中断了)。

**安全区域**

使用安全点进入STW有一个前提条件：即非垃圾收集线程是能"跑"的(已获得CPU的)，若设置了中断标志后线程正处于wait,block等状态，那么它就不能跑到最近的安全点上，让GC等待其获得CPU显然是不合理的。

为此引入了安全区域(Safe Region)。安全区域是指这样的一段代码：在该段代码内部，引用关系不会发生变化(因此，调用native方法的过程也会被定义为安全区域)。即只要线程没有离开安全区域，在其内部任意位置开始GC都是安全的。安全区域可以视为安全点的扩展。

总结一下的话，安全区域可以是：

- 线程无法移动的区域(wait,block)
- 线程可移动，但是线程的运行不会影响引用关系(这种情况的可能性较小)

当线程进入安全区域时，会为自身打上已经入安全区域的标志。这样GC就不必在意在安全区域中的线程了，也无须强制要求其中断。只是，当线程欲离开安全区域时，必须查看系统是否正处于STW中，若正处于STW中，则必须等待系统退出STW才能向下运行。

# 垃圾收集器

垃圾收集器是对上文所讨论的垃圾收集算法的具体实现。JVM规范中并未对垃圾收集器的实现细节做任何规定，因此各厂商的各代JVM之间的垃圾收集器均有较大的差异。本文讨论的垃圾收集器是JDK1.7中HotSpot VM所实现的垃圾收集器。其提供了多个垃圾收集器供使用者依需求组合使用，如下图所示：

![1.png](/images/blog_pic/JVM/垃圾收集/1.png)

图中两个垃圾收集器间若存在连线则证明可以组合使用。

顺带一提，JDK1.7，JDK1.8及JDK1.9中的默认垃圾收集器分别为：

- JDK1.7 : Parallel Scavenge + Parallel Old
- JDK1.8 : Parallel Scavenge + Parallel Old
- JDK1.9 : G1

**Serial**

最基本，发展历史最为悠久的新生代收集器。在JDK1.3.1之前，是唯一的新生代收集器。

如其名"串行的"所示，这是一个单线程收集器。整个GC过程将仅使用一个线程完成，采用的算法为改进的复制算法，在整个GC期间都需要STW。

Serial的缺点很明显：单线程无法利用多CPU的并发计算能力，全程STW，停顿时间过长。但是在JDK1.7中其依然是Clinet模式下的默认新生代垃圾收集器。原因就在于在单线程的环境下其实现简单高效，且在用户的桌面应用场景中，分配给JVM的内存通常不会太大，其中新生代通常也就在几十兆到几百兆之间，使用Serial收集器的停顿时间基本都能控制在几十毫秒至多两百毫秒之内，这个停顿时间通常都是可接受的。

**Parallel New**

Parallel New(后文简称为ParNew)是Serial的多线程版本。除了使用多线程完成GC过程以外，其余部分可认为与Serial一样(实际上二者确实也共用了相当多的代码)，采用的算法为改进的复制算法，GC依然全程STW。

在单CPU环境中ParNew往往是不如Serial的，而在并发环境中，ParNew较之Serial会有所提升，这与所有串行代码及其被改造为的并行代码的比较结论相同。默认情况下，ParNew开启的线程数与系统可用的CPU数相等。

由上文的收集器关系图可知，老年代收集器CMS只能与Serial或ParNew配合使用，所以在并发环境下，如果老年代选择CMS，则新生代的最优选择只能为ParNew。事实上，使用-XX:+UseConcMarkSweepGC指定CMS为老年代收集器后，新生代收集器自动的就会被指定为ParNew。

**Parallel Scavenge**

Parallel Scavenge(并发清理，下文简称为PS)如其名所示，是一个多线程的新生代收集器。其与其他的所有垃圾收集器的目标均不相同。

大多数的垃圾收集器的目标在于降低STW的停顿时间，或者具体来说，减少用户在使用时的卡顿感。而PS的目标在于提高系统的吞吐量，因此PS收集器又名吞吐量优先收集器。

所谓吞吐量(Throughput)即是指CPU运行用户代码的时间与CPU消耗的总时间的比值，其概念类似于内燃机中的有效功率。

举个例子，假设在100秒内有两种系统运行状况：

1. 系统停顿了1次用于GC，这1次停了10秒。其余时间都在运行用户程序，则这100秒的吞吐量为0.9。
2. 系统停顿了200次用于GC，每次0.1秒，合计停顿了20秒。其余时间都在运行用户程序，则这100秒内的吞吐量为0.8。

以停顿时间为优化目标的收集器会认为情况2更优。而以吞吐量为优化目标的收集器会认为情况1更优。

PS提供了-XX:MaxGCPauseMillis参数来设置最大的单次停顿时间。这是一个大于0的整数值，代表最大的停顿毫秒值。JVM将尽量保证单次GC时间不超过该值。这里的注意点有2：

1. 注意这仅仅是尽量。
2. 如上例所示，减少停顿往往是以牺牲吞吐量为代价的。另外可行的策略还有减小新生代的大小(需扫描的总空间小了收集自然快了)。

PS提供了-XX:GCTimeRatio参数用以精确控制吞吐量。该值是一个取值范围在(0,100)之间的整数。GC收集时间默认为1，非GC时间为该参数值。即若该值=2，则GC最多占总时间的1/3。默认该值为99，即GC最多占总时间的1/100。

PS提供了GC自适应的调节策略(GC Ergonomics)。用开关参数-XX:+UseAdaptiveSizePolicy开启。开启该参数后，只需要指定基本的参数(例如最大堆-Xmx)即可。其他小区域上的参数，例如新生代的大小-Xmn，新生代中Eden与一个Survivor的比例-XX:SurvivorRatio，晋升老年代的对象大小-XX:PretenureSizeThreshold等均无需手动设置，JVM会根据系统当前的运行情况做出动态的调整。

**Serial Old**

与Serial所配对的单线程的，基于标记-整理算法的老年代收集器。

类似于Serial的原因，Serial Old主要在Client模式下使用。

而在Server模式下，其用途主要有以下两点：

- 在JDK1.5及此前的版本，与PS配合使用(可以这样想，PS NTR 了Serial)：与PS所配对的老年代收集器Parallel Old诞生于JDK1.6。换言之，在JDK1.5及此前的版本，PS并没有与之配对的老年代收集器。此时PS使用其自带的PS MarkSweep(MSC)进行老年代垃圾的收集。该收集器与Serial Old的实现非常接近，因此在官方的资料中往往也会以Serial Old来代指PS MarkSweep。
- 使用CMS作为老年代收集器时，若其在并发收集的过程中发生了Concurrent Mode Failure，则Serial Old会作为后备收集器被使用。

**Parallel Old**

与PS所配对的多线程的，基于标记-整理算法的，诞生于JDK1.6的老年代收集器。

在Parallel Old诞生之前，PS只能与Serial Old(PS MarkSweep,MSC)配合使用，这就导致了很尴尬的局面：新生代以多线程收集，老年代以单线程收集。单线程环境中PS收集器拖累了Serial Old，而并发环境中Serial Old又拖累了PS。而且PS以吞吐量为优化目标，Serial Old以缩短STW为优化目标，二者的追求也不同。换句话说，NTR虽然很爽，但终究不伦不类，没有原配和谐：PS+Serial Old在单线程环境中不如Serial+Serial Old，在并发环境中不如ParNew+CMS。

PS+Parallel Old是吞吐量优先的程序的最优选择。

**Concurrent Mark Sweep**

Concurrent Mark Sweep(后文简称为CMS)是一种多线程的老年代收集器。

CMS基于标记-清除算法，为了最大限度的减少STW的时间，其将"标记"与"清除"又细化为如下4步。核心思想就是能并发着做的就尽量并发着做。

1. **初始标记(CMS initial mark)**：必须STW，只标记GC ROOT能直接关联的对象，相当于稍微扩大一下搜索的范围，因此该步速度很快。
2. **并发标记(CMS concurrent mark)**：无需STW。根据可达性分析算法从GC ROOT开始完成对象的标记，在此期间用户程序可正常运行。
3. **重新标记(CMS remark)**：必须STW。对并发标记过程中因用户线程活动导致的标记错误进行修正。很显然，这是一种乐观的加锁思维。若用户线程在并发标记阶段对标记的影响很小，那么重新标记很快就可完成。反之重新标记就可能会花费很长的时间。
4. **并发清除(CMS concurrent sweep)**：无需STW。在此期间用户程序可正常运行。这也是为什么CMS使用标记清除算法而非标记整理算法的原因：因为清除的过程中用户程序还在并行运行，因此不能移动对象。

除非特别的不幸，否则可并行的时间(并发标记+并发清除)是远大于必须STW的时间(初始标记+重新标记)的。因此总体来说，STW对用户程序的影响下降到了一个非常低的程度，故而CMS又被称为并发低停顿收集器(Concurrent Low Pause Collector)。目前很大一部分的Java应用集中在互联网站或B/S架构的Server端上，这类程序对服务响应时间非常敏感，因此对它们而言CMS是非常友好的。

当然，为了"减少STW"这一优化目标，CMS也付出了不小的代价：

- 虽然CMS会保证用户程序在GC期间尽可能的始终处于运行状态，但是终究无法运行得那么舒服：毕竟还要分出CPU资源来执行GC。默认情况下CMS创建的用于GC的线程数为(CPU数+3)/4的下取整。即若是在单CPU环境下用户依然相当于被完全的STW了，而在CPU较少时，例如只有2个，此时GC和用户程序各占用一个CPU，用户程序能利用的CPU资源直接减半。曾产生过这样的解决方案：增量式并发收集器(Incremental Concurrent Mark Sweep，简称为i-CMS)。类似于操作系统使用时间片轮转等抢占式机制在单CPU中模拟多任务环境，在并发标记及并发清除时垃圾收集线程无法完全独占CPU，从而尽量提高用户程序所能掌控的CPU资源。但是效果却不太理想：该机制延长了垃圾收集时间，例如独占一个CPU的情况下并发GC操作需要1毫秒，若采用交替执行的方式平均向两个线程分配CPU，并发GC操作所需的时间并非2毫秒，而是一个更大的值：因为线程的切换与恢复也需耗费CPU时间。因此JDK1.7中，i-CMS已被标记为deprecated，即不推荐开发人员使用。
- 无法处理浮动垃圾(Floating Garbage)。并发运行期间用户程序仍然可能产生新的垃圾，若重新标记动作已过，CMS就无法在本次GC中收集这部分垃圾而只能推迟至下一次。这一部分垃圾就被称为浮动垃圾。
- 垃圾收集动作提前。因为GC过程中用户程序尚在运行，那么在没有发生STW的并发运行期间CMS就必须为用户线程预留出足够的内存。其他老年代收集器可在老年代将满时才触发GC，而CMS必须将GC动作提前。JDK1.5中CMS在老年代使用68%时即触发GC，而到了JDK1.6中这个值已提升为92%。可通过-XX:CMSInitiatingOccupancyFraction参数手动设置该值。
- 可能出现Concurrent Mode Failure。CMS收集GC的阀值设置得过低会导致垃圾收集过于频繁，设置得过高又容易导致用户线程在GC期间的内存不足。无论该值设置为多大都只是一个经验值，且只要不是0，就无法完全确保用户线程的内存供应：即发生Concurrent Mode Failure。此时CMS将启动备用方案：对于本次GC而言，后续垃圾的收集将由Serial Old完成。显然，这是一个乐观锁的并发控制策略：先依经验设置一个GC阀值，而后乐观的认为不会或只会导致很少的Concurrent Mode Failure。若符合预期则性能不会受到太大的影响。若不符合预期性能会大幅下降。
- CMS采用的算法为标记-清除。这意味着CMS会产生内存碎片。为解决(或者说是缓解)这个问题，CMS提供了开关参数-XX:+UseCMSCompactAtFullCollection用于在因内存碎片而不得不产生新一次的Full GC之前允许进行压缩，默认该开关是打开的。CMS还提供了另一个参数-XX:CMSFullGCsBeforeCompaction用于控制压缩频率，这是一个自然数值，即每隔多少次不压缩的GC之后跟着一次压缩的GC。默认值为0，即每次GC后都需进行压缩。这样就完全避免了内存碎片问题，但每次GC的运行时间也不得不增长。

**Garbage-First**

Garbage-First(后文简称G1)管理下的堆的内存结构与其他垃圾收集器均有较大的差异，虽然逻辑上依然有新生代和老年代的概念，但是这两个区域不再在物理上隔离。在物理上，G1将堆划分为了多个大小相等的独立区域(Region)，新生代和老年代实际上是由一个个不连续的Region拼接而成的逻辑概念。因此，和其他所有的垃圾收集器都不同，G1可以收集整个堆的垃圾，而不仅仅是只有新生代或老年代。

G1是一款面向服务端应用的垃圾收集器。JDK1.6 6u14提供了G1的Early Access版本供开发人员体验，G1的这种Experimental状态持续了数年的时间直至JDK1.7 7u4才移除变为商用正式版。Sun期望其在未来能取代JDK1.5时诞生的CMS(Sun的继任者Oracle完成了这一点，JDK1.9的默认垃圾收集器已经变为了G1)。

G1的核心特点如下：

- G1以和CMS类似的策略实现了与CMS类似的缩短STW的功能。所不同的是CMS只能在老年代降低停顿，而G1将这个福利扩展为全堆。
- G1在逻辑上依然分为新生代及老年代，且对新生代及老年代中的对象有不同的收集策略。
- 从整体上看，G1采用标记-整理算法。从局部来看(两个Region之间)，G1采用标记-复制算法。因此，无论是从整理上还是局部上，G1都不会产生内存碎片。
- 除了尽可能的降低STW之外，G1还能建立可预测的停顿时间模型：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不超过N毫秒。

在物理层面上不区分新生代与老年代并没有增大每次GC所需扫描的内存区域，恰恰相反，G1还采用化整为零的思想大幅减少了每次GC需扫描的内存区域。这也是G1能建立可预测的停顿时间模型的原因。G1根据已获得的统计数据(每次回收获得的空间大小及所需时间等)预估出各Region的回收收益，并将其按回收收益由高至低排序维护一个优先列表。根据用户指定的停顿时间，选择出回收收益最大的区域组合(这也是Garbage-First这一名称的由来)。

G1之外的收集器在物理上将堆划分为了彼此隔离的新生代及老年代，表面上来说各收集器仅仅只需要扫描自己负责的区域即可。但是实现上却并非能这么简单：若新生代的某对象是通过老年代的某对象而被加入GC ROOT的引用链，那么起码必须要扫描到老年代中的那个对象才能保证标记的准确。而G1的矛盾则更为突出，因为其将堆在物理上划分为了远多于两个的Region，将需扫描的区域限定在一个Region之内更为困难。所有收集器都使用一个名为Remembered Set的数据结构来避免不必要的扫描。每个物理上隔离的区域都维护一份属于自身的Remembered Set。每当对对象的引用类型字段进行写操作时，都会产生一个Write Barrier暂时中断写操作，检查引用实际所引用的对象是否处于物理隔离的不同区域，若是，则将相关引用信息加入到被引用对象所在区域的Remembered Set中。当对某一区域进行垃圾收集时，将其他区域Remembered Set中被本区域对象引用的对象也设置为本次GC的GC ROOT即可。

类似于CMS，G1分为如下4步：

1. **初始标记(Initial Marking)**：必须STW，只标记GC ROOT能直接关联的对象，因此该步速度很快。
2. **并发标记(Concurrent Marking)**：无需STW。根据可达性分析算法从GC ROOT开始完成对象的标记，在此期间用户程序可正常运行。
3. **最终标记(Final Marking)**：必须STW。对并发标记过程中因用户线程活动导致的标记错误进行修正。很显然，这是一种乐观的加锁思维。若用户线程在并发标记阶段对标记的影响很小，那么重新标记很快就可完成。反之重新标记就可能会花费很长的时间。
4. **筛选回收(Live Data Counting and Evacuation)**：根据用户指定的GC停顿时间结合垃圾收集收益优先列表确定回收计划。其实本步是可以不用STW的，但是计划制定后时间本就是可控在用户指定的范围之内了，因此G1会在本步STW以提升垃圾收集效率。

G1转为正式版的时间较短，因此在商业生产环境中的应用并不多，主流依然是使用ParNew+CMS实现替代的功能。

# 阅读GC日志文件

-XX:+PrintGCDetails：显式打印GC日志细节。

不同收集器的GC日志有细节上的差异，但总体来说有一个共性的规范。

以如下的GC日志片段(JDK1.7)为例：

```
[GC [PSYoungGen: 5427K->536K(38400K)] 5427K->536K(124416K), 0.0090463 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 
[Full GC [PSYoungGen: 536K->0K(38400K)] [ParOldGen: 0K->468K(86016K)] 536K->468K(124416K) [PSPermGen: 2563K->2562K(21504K)], 0.0120810 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
```

开头的[GC及[Full GC表示GC类型。[GC是新生代GC，[Full GC是全内存GC。

随后的[PSYoungGen，[ParOldGen，[PSPermGen等表示本次GC所涵盖的区域。对于每个区域而言，后续的都是：GC前本区域所用空间->GC后本区域所用空间(本区域总空间)。再随后的是GC耗时，单位为秒。

则仔细分析上述GC日志片段：

```
[GC [PSYoungGen: 5427K->536K(38400K)] 5427K->536K(124416K), 0.0090463 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]
```

本行GC代表新生代GC([GC)，新生代使用Parallel Scavenge收集器([PSYoungGen)，该收集器的收集情况为：进行GC前占用新生代内存5427K，GC完成后占用新生代内存536K(新生代总大小38400K)。从整个堆的角度看：进行GC前占用内存5427K，GC完成后占用内存536K(堆总大小124416K)。本次GC耗时0.0090463秒。

[Times: user=0.05 sys=0.00, real=0.01 secs]与Linux的time命令所输出的时间含义一致，即：

- user:用户态消耗的CPU时间
- sys:内核态消耗的CPU时间
- real:操作从开始到结束所经过的墙钟时间(Wall Clock Time)

CPU时间与墙钟时间的区别在于，CPU时间就是指CPU运算所需的时间。而墙钟时间在此基础上又加入了各种非运算的等待耗时，例如磁盘I/O，线程阻塞等。

如果有多个CPU或CPU为多核的话，CPU时间是指这复数个CPU时间的总和，因此并发环境下CPU时间往往反而会超过墙钟时间。

# 垃圾收集参数

**-XX:+UseSerialGC**

打开此开关后，将使用Serial+Serial Old的收集器组合进行垃圾收集。这也是Client模式下的默认值。示例代码如下：

```
public class Test {

    private static final int _1MB = 1024 * 1024;

    /**
     * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseSerialGC
     */
    public static void main(String[] args) {
        byte[] a1, a2, a3, a4,a5,a6,a7;
        a1 = new byte[2 * Test._1MB];
        a2 = new byte[2 * Test._1MB];
        a3 = new byte[2 * Test._1MB];
        a4 = new byte[2 * Test._1MB];    // 触发Minor GC
        a5 = new byte[2 * Test._1MB];
        a6 = new byte[2 * Test._1MB];
        a7 = new byte[2 * Test._1MB];    // 触发Full GC
    }
}
```

输出如下：

```
[GC[DefNew: 6980K->469K(9216K), 0.0046578 secs] 6980K->6613K(19456K), 0.0047158 secs] [Times: user=0.00 sys=0.02, real=0.01 secs] 
[GC[DefNew: 6787K->6787K(9216K), 0.0000141 secs][Tenured: 6144K->8192K(10240K), 0.0048865 secs] 12931K->12755K(19456K), [Perm : 2563K->2563K(21248K)], 0.0049309 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
Heap
 def new generation   total 9216K, used 6693K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  81% used [0x00000000f9a00000, 0x00000000fa0896d0, 0x00000000fa200000)
  from space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
  to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)
 tenured generation   total 10240K, used 8192K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  80% used [0x00000000fa400000, 0x00000000fac000c8, 0x00000000fac00200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 2570K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  12% used [0x00000000fae00000, 0x00000000fb0829c8, 0x00000000fb082a00, 0x00000000fc2c0000)
No shared spaces configured.
```

**-XX:+UseParNewGC**

打开此开关后，将使用ParNew+Serial Old的收集器组合进行垃圾收集。示例代码如下：

```
public class Test {

    private static final int _1MB = 1024 * 1024;

    /**
     * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseParNewGC
     */
    public static void main(String[] args) {
        byte[] a1, a2, a3, a4,a5,a6,a7;
        a1 = new byte[2 * Test._1MB];
        a2 = new byte[2 * Test._1MB];
        a3 = new byte[2 * Test._1MB];
        a4 = new byte[2 * Test._1MB];
        a5 = new byte[2 * Test._1MB];
        a6 = new byte[2 * Test._1MB];
        a7 = new byte[2 * Test._1MB];
    }
}
```

输出如下：

```
[GC[ParNew: 6980K->479K(9216K), 0.0039713 secs] 6980K->6623K(19456K), 0.0040409 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC[ParNew: 6797K->6797K(9216K), 0.0000098 secs][Tenured: 6144K->8192K(10240K), 0.0046224 secs] 12941K->12755K(19456K), [Perm : 2563K->2563K(21248K)], 0.0046706 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 par new generation   total 9216K, used 6693K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  81% used [0x00000000f9a00000, 0x00000000fa0896d0, 0x00000000fa200000)
  from space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
  to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)
 tenured generation   total 10240K, used 8192K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
   the space 10240K,  80% used [0x00000000fa400000, 0x00000000fac000c8, 0x00000000fac00200, 0x00000000fae00000)
 compacting perm gen  total 21248K, used 2570K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
   the space 21248K,  12% used [0x00000000fae00000, 0x00000000fb0829c8, 0x00000000fb082a00, 0x00000000fc2c0000)
No shared spaces configured.
```

**-XX:+UseConcMarkSweepGC**

打开此开关后，将使用ParNew+CMS(Serial Old为发生Concurrent Mode Failure时的后备)的收集器组合进行垃圾收集。示例代码如下：

```
public class Test {

    private static final int _1MB = 1024 * 1024;

    /**
     * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC
     */
    public static void main(String[] args) {
        byte[] a1, a2, a3, a4,a5,a6,a7;
        a1 = new byte[2 * Test._1MB];
        a2 = new byte[2 * Test._1MB];
        a3 = new byte[2 * Test._1MB];
        a4 = new byte[2 * Test._1MB];
        a5 = new byte[2 * Test._1MB];
        a6 = new byte[2 * Test._1MB];
        a7 = new byte[2 * Test._1MB];
    }
}
```

输出如下：

```
[GC[ParNew: 6816K->490K(9216K), 0.0031159 secs] 6816K->6636K(19456K), 0.0032050 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC[ParNew: 6888K->6888K(9216K), 0.0000282 secs][CMS: 6146K->8192K(10240K), 0.0080740 secs] 13034K->12756K(19456K), [CMS Perm : 2564K->2563K(21248K)], 0.0081410 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
[GC [1 CMS-initial-mark: 8192K(10240K)] 14804K(19456K), 0.0005862 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 par new generation   total 9216K, used 6775K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)
  eden space 8192K,  82% used [0x00000000f9a00000, 0x00000000fa09df78, 0x00000000fa200000)
  from space 1024K,   0% used [0x00000000fa300000, 0x00000000fa300000, 0x00000000fa400000)
  to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)
 concurrent mark-sweep generation total 10240K, used 8192K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)
 concurrent-mark-sweep perm gen total 21248K, used 2570K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)
```

**-XX:+UseParallelGC 或 -XX:+UseParallelOldGC**

打开此开关后，将使用Parallel Scavenge+Parallel Old的收集器组合进行垃圾收集。这也是Server模式(JDK的默认模式)下的默认值。

示例代码如下：

```
public class Test {

    private static final int _1MB = 1024 * 1024;

    /**
     * -Xms20m -Xmx20m -Xmn10m -XX:+PrintGCDetails
     */
    public static void main(String[] args) {
        byte[] a1, a2, a3, a4,a5,a6,a7;
        a1 = new byte[2 * Test._1MB];
        a2 = new byte[2 * Test._1MB];
        a3 = new byte[2 * Test._1MB];
        a4 = new byte[2 * Test._1MB];
        a5 = new byte[2 * Test._1MB];
        a6 = new byte[2 * Test._1MB];
        a7 = new byte[2 * Test._1MB];
    }
}
```

输出如下：

```
[GC [PSYoungGen: 6980K->600K(9216K)] 6980K->6744K(19456K), 0.0032780 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[Full GC [PSYoungGen: 600K->0K(9216K)] [ParOldGen: 6144K->6612K(10240K)] 6744K->6612K(19456K) [PSPermGen: 2563K->2562K(21504K)], 0.0113665 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
[Full GC [PSYoungGen: 6317K->4096K(9216K)] [ParOldGen: 6612K->8659K(10240K)] 12929K->12755K(19456K) [PSPermGen: 2562K->2562K(21504K)], 0.0070159 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 9216K, used 6226K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 76% used [0x00000000ff600000,0x00000000ffc148c8,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
 ParOldGen       total 10240K, used 8659K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 84% used [0x00000000fec00000,0x00000000ff474ed0,0x00000000ff600000)
 PSPermGen       total 21504K, used 2569K [0x00000000f9a00000, 0x00000000faf00000, 0x00000000fec00000)
  object space 21504K, 11% used [0x00000000f9a00000,0x00000000f9c82640,0x00000000faf00000)
```

**-XX:SurvivorRatio=?**

Eden与Survivor的一个区的比值。默认值为8。

**-XX:+PrintGCDetails**

打印如下信息至控制台：

1. 发生GC时打印GC日志。
2. 进程退出时打印当前内存各区域的分配情况。

# 显式调用GC

```
System.gc();
```

或

```
Runtime.getRuntime().gc();
```

- 显式调用GC只是建议而非命令，因此JVM可能会屏蔽掉显式垃圾回收调用，因此并非调用了就一定会有效。
- 不推荐采用显式调用的方式进行垃圾回收，推荐将垃圾回收完全托管给JVM。