---
title: Java 并发-JVM所做的锁优化
date: 2018-04-27 20:49:36
tags: [Java,并发,锁]
categories: Java 并发
---

本文将向大家简单介绍几种JVM内部的"锁"优化策略。

<!-- more -->

# 锁偏向

锁偏向是一种针对加锁操作的优化手段。它的核心思想为：

**如果一个线程获得了锁，那么锁就会进入偏向模式。当这个线程再次请求该锁时，无需再做任何同步操作。**

这样便能节省大量有关锁申请的操作，从而提高系统的性能。

对于几乎没有锁竞争的场合，偏向锁的优化效果较好。因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争较为激烈的场合，其效果则不佳：最坏的情况下锁不会接到任何连续的来自同一个线程的请求，此时偏向模式等同于失效，其性能还不如不开启偏向锁(准备了一大顿没用上)。

使用JVM参数-XX:+UseBiasedLocking可以开启偏向锁。

# 轻量级锁

锁偏向失败后，JVM仍不会按通常套路为线程申请锁(我们将这种锁称为重量级锁)，而是会为线程申请轻量级锁。简单来说，锁偏向的目的是为了不要申请，而在锁偏向失败后，就不得不申请了，轻量级锁的目的是为了申请的成本低一些：它会在锁对象头部开辟出一片空间，作为指针指向持有该锁的线程，如果这一指向操作成功，则线程成功获得轻量级锁。如果该操作失败，说明此前该指针已指向别的线程了(即有其他线程优先获得了该轻量级锁)，此时对于该线程而言，锁将膨胀为重量级锁。

# 自旋锁

一旦膨胀为重量级锁，说明此时已有其他线程占有了该锁。那么理论上，线程应进入锁的等待队列，并有可能被真实的在操作系统层面挂起：很多时候，这是不太合理的，比如虽然现在尚无法获得锁，但在很短的时间后(比如几个CPU时钟周期)就能获取锁了，那么此时简单粗暴的频繁挂起及恢复线程就不是一个合理的做法。不过话又说回来，谁又能明确知道多久能获得锁呢？万一时间非常久呢？此种情况下，挂起线程，让出它已占据的资源才是合理的做法。

对此，JVM采取了一个折中的方案。当锁膨胀为重量级锁后，线程并不会立即被挂起，而是会做几个空循环(这也是自旋锁名称的由来)，说穿了，这就是在为了避免被立即挂起而争取时间：线程会在自旋结束后再次对锁发起申请，如果仍未获得锁，那么才会真正的进入锁的等待队列，并有可能真实的在操作系统层面被挂起。

# 锁消除

前文我们已讨论了3种优化策略：

- 锁偏向
- 轻量级锁
- 自旋锁

它们都有一个大的前提：那就是默认加锁操作确实是必要的。而锁消除是一种更彻底的优化，它在探讨更深的论题：代码里虽然写了要加锁，但这不过是程序员的主观判断，那么实际上到底是否真的需要加锁呢？对此，JVM在进行JIT编译时，会通过对运行上下文的扫描，去除不可能存在资源竞争的锁。

说到这里，我们不禁会去想，这算不算系统为程序员的不足买单呢？事实上并非完全如此。首先，程序员确实可能会错误的加锁，但是这是很难避免的，很多时候，当我们使用Java API或第三方提供的某些容器时，并不会特别较真的研究它的底层实现，到底哪里加了锁，性能又如何如何，往往功能满足需求即可。当然，知道的话更好，但对广大基层程序员提出那么高的门槛要求是不现实的。此外，我们使用线程安全的容器往往是因为它会身处于并发环境中，但这并不意味着对它所有的请求都是并发的。实际情况往往是并行与串行的请求共存，而只要有并行的请求存在，程序员就会选用线程安全的容器。那些没必要加锁的情景也需要系统的优化。

举一个小例子吧，我们来看如下代码：

```
public Integer[] test() {
    int length = 10;
    Vector<Integer> v = new Vector<Integer>(length);
    for (int i = 0; i < length; i++) v.add(i);
    return v.toArray(new Integer[length]);
}
```

上例中的Vector是一个线程安全的容器，然而它却只是一个单纯的局部变量，终其一生也没有逃逸出它所属的test()方法。换句话说，它的整个生命周期都是在虚拟机栈的栈帧中读过的，这是一个串行的环境，因此，此时的加锁就是没有必要的。当系统检测到后，就会将相应的锁消除。

因此，判断是否可进行锁消除的最重要的依据就是变量是否逃逸出了串行环境。该技术被称为逃逸分析：即判断某一个变量是否会逃出某一个作用域。在上例中，变量v显然没有逃出test()函数之外，因此JVM才敢于将v内部的加锁操作消除。如果test()函数返回的是v本身，也就是说v逃逸出了当前函数，它就有可能身处于并发的环境中了，进而被其他线程访问到。此时仅以这一个函数所掌握的情报就无法对v进行锁消除了。

使用-XX:+EliminateLocks可开启锁消除。如前所述，若欲开启锁消除，还需开启它所依赖的逃逸分析。逃逸分析只能在-server模式下运行，使用-XX:+DoEscapeAnalysis开启。