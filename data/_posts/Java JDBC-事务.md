---
title: Java JDBC-事务
date: 2017-10-12 20:33:36
tags: [Java,并发,事务,JDBC]
categories: Java JDBC
---

只有存在并发数据访问时才需要事务。

# 事务的ACID

- 原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败
- 一致性(Consistent)：事务必须使数据库从一个一致性状态变到另一个一致性状态
- 隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态
- 持久性(Durable)：事务完成后所做的改动都会被持久化。即使发生灾难性的失败，都可以通过日志和同步备份在故障发生后重建数据

<!-- more -->

# 事务常见问题

当多个事务访问同一数据时，可能会存在5类问题：包括3类数据读取问题(脏读，不可重复读和幻读)和2类数据更新问题(第1类丢失更新和第2类丢失更新)。

**脏读(Dirty Read)**

A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。

![0.jpg](/images/blog_pic/Java JDBC/事务/0.jpg)

**不可重复读(Unrepeatable Read)**

事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。

![1.jpg](/images/blog_pic/Java JDBC/事务/1.jpg)

**幻读(Phantom Read)**

事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行。

![2.jpg](/images/blog_pic/Java JDBC/事务/2.jpg)

**第1类丢失更新**

事务A撤销时，把已经提交的事务B的更新数据覆盖了。

![3.jpg](/images/blog_pic/Java JDBC/事务/3.jpg)

**第2类丢失更新**

事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。

![4.jpg](/images/blog_pic/Java JDBC/事务/4.jpg)

# 常见问题的对策

数据库通常会通过锁机制来解决数据并发访问问题。按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁。

直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析SQL语句然后为事务访问的资源加上合适的锁。ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别，如下表所示：

![5.jpg](/images/blog_pic/Java JDBC/事务/5.jpg)

# JDBC中的事务处理

Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务，当事务完成后用commit()显式提交事务。如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0开始还引入了Savepoint(保存点)的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。