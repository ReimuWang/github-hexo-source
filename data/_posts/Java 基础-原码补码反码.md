---
title: Java 基础-原码补码反码
date: 2017-11-06 00:46:49
tags: [Java,原码,补码,反码]
categories: Java 基础
---

Java中的整数(long,int,short,byte)均为有符号数，第一位代表符号位(0:正数,1:负数)。内存中以补码存储。

下文均以byte举例。

<!-- more -->

**原码**

原码是给人读的。即符号位+绝对值。

7原码：00000111

-7原码：10000111

**反码**

反码为原码到补码间的过渡。正数的反码与原码相同。负数符号位不变，其余位取反。

7反码：00000111

-7反码：11111000

**补码**

补码是机器存储用的。正数的补码与其原码及反码相同。负数的补码为反码加1。进位不会改变符号位。

7补码：00000111

-7补码：11111001

计算机中存储的值均为补码，因此负数求原码的方法为减1取反。

# 示例

```
public class Test {

    public static void main(String[] args) {
        int i = Integer.MAX_VALUE + 1;
        System.out.println(i);
        System.out.println(Integer.toBinaryString(i));
        
    }
}
```

输出：

```
-2147483648
10000000000000000000000000000000
```

推演：

Integer.MAX_VALUE为：01111111-11111111-11111111-11111111

加1后为：10000000-00000000-00000000-00000000。该值为负数并以补码的形式在内存中存储。其原码为减1后取反，即：

减1：11111111-11111111-11111111-11111111
取反：10000000-00000000-00000000-00000000

即其原码与补码相同。因此这是一个特殊的负数：实际上其表示的为-0。但为0划分正负没有意义。0已由+0表示。则该值就赋予一个特殊值，即负数的最小值-2^31(Integer.MIN_VALUE)。

# 示例

```
System.out.println(Integer.toBinaryString(-32));
```

输出：

```
11111111111111111111111111100000
```

推演：

-32原码：10000000-00000000-00000000-00100000
-32反码：11111111-11111111-11111111-11011111
-32补码：11111111-11111111-11111111-11100000

补码即为计算机中存储的值。