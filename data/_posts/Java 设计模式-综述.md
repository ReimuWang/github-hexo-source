---
title: Java 设计模式-综述
date: 2018-06-01 15:00:49
tags: [Java,设计模式]
categories: Java 设计模式
---

近年来，IT业界发生了翻天覆地的变化，各种开源框架层出不穷，机器学习大行其道。但是，在面向对象编程中，设计模式的重要性却不曾改变。在大规模的企业系统开发中，设计模式可以帮助我们实现系统结构化，很好的支撑起系统的稳定性和可扩展性。

<!-- more -->

# GoF

提起面向对象的设计模式，首先不得不说的就是由GoF联合编制的《Design Patterns: Elements of Reusable Object-Oriented Software》一书，中文译名为《设计模式：可复用面向对象软件的基础》(后文将简称为《设计模式》或GoF书)，它介绍了23种经典的设计模式，可谓是设计模式领域的"圣经"与基石(较真的说，该书介绍的仅仅只是面向对象编程的设计模式，面向过程的设计模式不在该书讨论的范畴之内。不过后文将不再纠结这个问题，除非特别声明，否则提到设计模式时默认均是指面向对象编程的设计模式)，有着极其重要的意义。

![0.jpg](/images/blog_pic/Java 设计模式/综述/0.jpg)

所谓GoF，实际是Gang of Four的缩写，也就是所谓的"四人组"(这命名颇有些F4，小虎队之类偶像团体的意思，不过这四个人确实也是计算机领域受万民敬仰的超级偶像了)，这四位大神分别是：

- Erich Gamma
- Richard Helm
- Ralph Johnson
- John Vlissides

GoF于1995年联合写成了《设计模式》一书，因此该书也被称作"GoF书"。

GoF书虽然有着重要的历史地位，但却存在两个阻碍初学者探究设计模式的小障碍：

1. 该书实际上是基于这4位大佬的博士论文整理而成的，因此学术性较强，初学者很难看懂书中想要表述的意思。

2. 虽说设计模式是超脱于语言的存在，但是为了演示举例，终归还是需要一种实际的语言将其落到实处。GoF书采用的是C++与Smalltalk，这就使得对这两种语言不是很熟悉的程序员更加难以理解。

因此，比起GoF书，对于设计模式的初学者而言，更为推荐的是对GoF书的二次解读。例如，对于Java程序员而言，我推荐结城浩编著的《图解设计模式》一书：

![1.jpg](/images/blog_pic/Java 设计模式/综述/1.jpg)

# 设计模式是什么

想必大家在编写程序的时候，都曾遇到过这样的情况：接到了一个新的需求，虽然需求是新的，但对程序员而言，其实"并不是什么新东西"。此时，我们就可以将过往的经验应用到这个新的需求上，使得开发更为顺畅。随着工作经验的增长，尤其是当我们善于总结的时候，这种情况将出现得越来越频繁，新需求虽然千变万化，但是经过抽象建模与问题分解后，基本都能找到相对固定，经过时间检验的解决对策，也就是所谓的"套路"，或者我们可以换一个更严谨的名称：设计模式。所以通俗的说，设计模式就是指针对软件开发过程中重复发生的问题的解决办法。

GoF为常用的23种设计模式赋予了"名字"，并按类型对它们进行了整理，最终产出的就是那本大名鼎鼎的《设计模式》。这本书的意义是里程碑式的，之所以这么说，是因为它不仅仅是一本"武功秘籍"，可以快速的提高程序员的水平，更重要的是，它提供了一种标准。在GoF书诞生之前，设计模式其实是一直存在的：其实自打第一句Hello World被打印出来时设计模式就相应的存在了，每个程序员在编程中都会有意或无意的积累属于自己的"套路"，但是此时的设计模式仅仅只能是技术，它存在于每个程序员的心中，却无法成为科学：因为并没有一个统一的标准说这种"套路"就叫这种设计模式，虽然对于不同的程序员而言，随着编程能力的进步，在大的思路上，解决同一个问题的套路总是趋向于殊途同归，但是在细节上却终归是有着差距，这是无法避免的。

《设计模式》一书的诞生解决了这个问题，它所介绍的23种设计模式被所有主流程序员所学习与认同，这样，当两个程序员在讨论一个问题的解决策略时，如果一个程序员说出：我认为可以用GoF书中的[4.Factory Method模式]()解决这个问题，那么另一个程序员马上就可以理解他想表达的是什么而不会产生歧义，这在需要多人参与开发的复杂项目中有着非凡的意义。不仅如此，GoF书通过介绍那23种设计模式还普及开了一套科学的描述设计模式的方法(主要是UML图)，因为实际需求总是有其特殊性的，我们不可能用这23种设计模式涵盖天下所有的需求，很多时候，我们需要使用某种设计模式的变种，或者组合某几种设计模式，甚至是创造出一种全新的设计模式，此时沟通的作用就更为重要了：如何从零让别人理解你的想法？如何从零理解别人的想法？在两人想法不同时，如何进行讨论？设计模式为开发人员提供了有益且丰富的词汇，让开发人员可以更容易的理解对方所要表达的意思。

GoF书中所介绍的23种设计模式并不是孤立的，而是互相关联的。设计模式不需要死记硬背，因为一个东西并不是成为了"套路"才是正确的，而是因为它是正确的，它是有用的，才能成为"套路"。因此学习设计模式，最重要的是多实践，多练习。在阅读代码时识别设计模式，在编写代码时运用设计模式。这一切都应是自然而然，水到渠成的。归根结底一句话：让GoF书中介绍的那23种设计模式成为属于自己的套路才是最重要的。

# 设计模式与模式

严格地说，设计模式是模式的子概念。

不论是在什么领域，给"在某种场景下重复发生的问题的解决办法"赋予名字，并整理而成的东西一般都被称为"模式"。

设计模式是适用于软件设计和开发领域的模式，它是模式中的一种。

不过，有时候在软件领域也会将"设计模式"简称为"模式"(设计模式是模式的子概念，当然可以这样简称，是没有歧义的)。

例如，我们在介绍设计模式时，因为有一个很明确的范围，所以有时也会以"模式"来代指"设计模式"。比如，我们说"GoF书中介绍了23种模式"实际指得就是"GoF书中介绍了23种设计模式"。再比如，我们给这23种设计模式命名时，也会将其简称为xx模式。例如[1.Iterator模式]()实际上指得就是"Iterator设计模式"。

# 设计模式与算法

设计模式与算法是两个不同的概念，不过二者之间有着很深的联系。

算法(algorithm)是指根据输入数据获取输出数据的一系列机械的步骤。算法必须在有限的时间内结束。二分查找算法和快速排序算法等都是经典的算法。

我们也可以将算法看作是"解决问题的办法"，在不太严谨的场合，也可以将其视为设计模式，但是算法并不等同于设计模式。

设计模式不仅与算法有关，它还与习语(idiom)有关。习语是指编程时经常使用的固定语法(惯用语)。通常，习语具有"高度依赖于编程语言"的特征。与算法一样，习语也可以被看作是"解决问题的办法"，在不太严谨的场合，同样可以将其视为设计模式，但是习语依然并不等同于设计模式。

通常，我们在使用设计模式时，最终都会落实到具体的算法，进而落实到特定语言的实现(习语)。但是设计模式其实并非具体的实现，它是更抽象的东西：实现背后的思考方式和解决方法才是设计模式。

# 接口和API

在描述设计模式时，我们常会提起两个关键词："接口"与"API"(Application Programming Interface，即应用程序编程接口)。

一般而言，在提到"某个类的接口"时，多是指该类所持有的方法的集合，在这种语境下，"接口"和"API"的含义基本是等同的，都是指类暴露给外部的功能。

不过对于Java程序员而言，"接口"指得就是"被interface关键字声明的代码"，而"API"则和通常的理解相同，指类暴露给外部的功能。

因为我将以Java来介绍设计模式，因此会以Java的规则严格区分"接口"与"API"。

# 面向对象的"六原则一法则"

从具体的使用层面来讲，我们可以将设计模式分为多种(例如GoF就将设计模式分为了23种)，这就好比具体的武功，例如天山折梅手，六脉神剑之类的。而从更抽象的层面来讲，设计模式有着一些类似于原则或是法则之类的东西，它们不是具体的设计模式，但是具体的设计模式却是这些法则的具现。这就好比武学要义，例如"天下武功，唯快不破"。或者说，这些法则是指导思想，政治精神，而设计模式则是基于指导思想制定的具体策略。

在面向对象领域，它们被总结为了"六原则一法则"：

首先是六原则：

- 单一职责原则：模块内部高内聚，实现的功能尽量保证单一纯粹。模块之间低耦合，系统中某模块的替换对系统的影响尽可能的小。
- 开闭原则(The Open-Closed Principle,OCP)：该原则由勃兰特·梅耶提出，而后RobertC.Martin在C++ Report(1996年1月)中的Engineering NoteBook专栏里对其进行了总结。简单来说，该原则可以被描述为：对扩展(extension)开放(open)，对修改(modification)关闭(close)。即：增加新功能时，尽量只需派生新类而无需修改已有代码。要点有二：1.设计好系统主线的继承关系。2.使用接口及抽象类抽象核心功能。
- 依赖倒转原则：即面向接口编程。声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型。
- 里氏替换原则(
    Liskov Substitution Principle,LSP)：任何时候，能用父类型的地方就一定能使用其子类型进行替换。换句话说，无论父类类型的引用具体指向的是它的哪个子类实例，程序都应该能正常运行。该原则常用于判断继承关系是否合理。例如，[3.Template Method模式]()就是该原则的具体应用。
- 接口隔离原则：接口应高内聚。其所表示的能力应尽量保证单一纯粹。
- 合成聚合复用原则：类与类之间有三种关系：继承(Is-A)，关联(Has-A)，依赖(Use-A)。其中，关联根据其关联的强度又可以进一步划分为关联、聚合和合成。本原则的要义是优先使用关联/依赖而非继承复用代码。例如，任何时候都不要继承工具类：你使用工具，你并不是工具。

然后是一法则：

- 最少知识法则(迪米特法则)：一个对象应当对其他对象有尽可能少的了解。即不要和陌生人打交道，如果真的需要，找一个自己的朋友，让他替你和陌生人打交道。该法则是低耦合的体现，例如，[15.Facade模式]()就是该法则的具体应用。

# GoF书中的23种设计模式(《图解设计模式》一书中的划分方式)

GoF书将它所介绍的那23种设计模式分为了3大类。从学习者的角度来看，这个划分稍显宽泛了些。个人更偏爱《图解设计模式》中的划分方式，该书将这23种设计模式划分为了10个部分：

**第1部分：适应设计模式**

该部分的设计模式相对而言都很易于理解，可以帮助初学者快速的适应设计模式的一些基本术语和概念。

- [1.Iterator模式]()
- [2.Adapter模式]()

**第2部分：交给子类**

该部分将介绍与类的继承相关的设计模式。

- [3.Template Method模式]()
- [4.Factory Method模式]()

**第3部分：生成实例**

该部分将介绍与生成实例相关的设计模式。

- [5.Singleton模式]()
- [6.Prototype模式]()
- [7.Builder模式]()
- [8.Abstract Factory模式]()

**第4部分：分开考虑**

将易变得杂乱无章的处理分开考虑。

- [9.Bridge模式]()
- [10.Strategy模式]()

**第5部分：一致性**

让两个看上去不同的对象的操作变得统一。

- [11.Composite模式]()
- [12.Decorator模式]()

**第6部分：访问数据结构**

该部分将介绍优化数据结构处理的设计模式。

- [13.Visitor模式]()
- [14.Chain of Responsibility模式]()

**第7部分：简单化**

让类与类之间的关系变得简单。

- [15.Facade模式]()
- [16.Mediator模式]()

**第8部分：管理状态**

该部分将介绍与状态相关的设计模式。

- [17.Observer模式]()
- [18.Memento模式]()
- [19.State模式]()

**第9部分：避免浪费**

该部分将介绍避免浪费，提高处理效率的设计模式。

- [20.Flyweight模式]()
- [21.Proxy模式]()。

**第10部分：用类来表现**

用类来表现特殊的东西。

- [22.Command模式]()
- [23.Interpreter模式]()

# GoF书中的23种设计模式(原书中的划分方式)

我们不妨将GoF书中原有的对23种设计模式的3种划分方式也贴出来：

**创建型设计模式：对类的实例化过程的抽象化**

- [8.Abstract Factory模式]()
- [4.Factory Method模式]()
- [5.Singleton模式]()
- [7.Builder模式]()
- [6.Prototype模式]()

**结构型设计模式：描述如何将类或对象结合在一起形成更大的结构**

- [2.Adapter模式]()
- [11.Composite模式]()
- [15.Facade模式]()
- [21.Proxy模式]()
- [9.Bridge模式]()
- [12.Decorator模式]()
- [20.Flyweight模式]()

**行为型设计模式：对在不同的对象之间划分责任和算法的抽象化**

- [14.Chain of Responsibility模式]()
- [23.Interpreter模式]()
- [16.Mediator模式]()
- [17.Observer模式]()
- [10.Strategy模式]()
- [13.Visitor模式]()
- [22.Command模式]()
- [1.Iterator模式]()
- [18.Memento模式]()
- [19.State模式]()
- [3.Template Method模式]()

# Java API中用到的设计模式

Java标准类库其实也是普通的基于Java语法实现特定功能的代码，其中自然也运用了大量的设计模式，有很多就包含在GoF所介绍的那23种设计模式之中。我们不妨举几个例子：

---

java.util.Iterator是用于遍历元素集合的接口。这里使用了[1.Iterator模式]()。

---

java.util.Observer是用于观察对象状态变化的接口，这里使用了[17.Observer模式]()。

---

以下方法中使用了[4.Factory Method模式]()：

- java.util.Calendar类的getInstance()方法。
- java.security.SecureRandom类的getInstance()方法。
- java.text.NumberFormat类的getInstance()方法。

---

java.awt.Component与java.awt.Container这两个类使用了[11.Composite模式]()。